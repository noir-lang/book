<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Noir Programming Language</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
                <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">The Noir Programming Language</a></li><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started/nargo.html"><strong aria-hidden="true">1.1.</strong> Nargo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started/nargo/installation.html"><strong aria-hidden="true">1.1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="getting_started/nargo/commands.html"><strong aria-hidden="true">1.1.2.</strong> Commands</a></li></ol></li><li class="chapter-item expanded "><a href="getting_started/hello_world.html"><strong aria-hidden="true">1.2.</strong> Hello, World</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started/breakdown.html"><strong aria-hidden="true">1.2.1.</strong> Breakdown</a></li></ol></li><li class="chapter-item expanded "><a href="getting_started/tornado_cash.html"><strong aria-hidden="true">1.3.</strong> TornadoCash</a></li><li class="chapter-item expanded "><a href="getting_started/typescript.html"><strong aria-hidden="true">1.4.</strong> TypeScript</a></li></ol></li><li class="chapter-item expanded "><a href="language_concepts.html"><strong aria-hidden="true">2.</strong> Language Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language_concepts/mutability.html"><strong aria-hidden="true">2.1.</strong> Mutability</a></li><li class="chapter-item expanded "><a href="language_concepts/data_types.html"><strong aria-hidden="true">2.2.</strong> Data types</a></li><li class="chapter-item expanded "><a href="language_concepts/functions.html"><strong aria-hidden="true">2.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="language_concepts/comments.html"><strong aria-hidden="true">2.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="language_concepts/control_flow.html"><strong aria-hidden="true">2.5.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="language_concepts/ops.html"><strong aria-hidden="true">2.6.</strong> Operations</a></li><li class="chapter-item expanded "><a href="language_concepts/constrain.html"><strong aria-hidden="true">2.7.</strong> Constrain Statement</a></li></ol></li><li class="chapter-item expanded "><a href="modules_packages_crates.html"><strong aria-hidden="true">3.</strong> Modules, Packages, Crates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="modules_packages_crates/crate.html"><strong aria-hidden="true">3.1.</strong> Crate</a></li><li class="chapter-item expanded "><a href="modules_packages_crates/packages.html"><strong aria-hidden="true">3.2.</strong> Packages</a></li><li class="chapter-item expanded "><a href="modules_packages_crates/modules.html"><strong aria-hidden="true">3.3.</strong> Modules</a></li><li class="chapter-item expanded "><a href="modules_packages_crates/dependencies.html"><strong aria-hidden="true">3.4.</strong> Dependencies</a></li></ol></li><li class="chapter-item expanded "><a href="acir.html"><strong aria-hidden="true">4.</strong> ACIR</a></li><li class="chapter-item expanded "><a href="c_overview.html"><strong aria-hidden="true">5.</strong> Compilation Overview</a></li><li class="chapter-item expanded "><a href="coming_soon.html"><strong aria-hidden="true">6.</strong> Coming!</a></li><li class="chapter-item expanded "><a href="license.html"><strong aria-hidden="true">7.</strong> LICENSE</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Noir Programming Language</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-noir-programming-language"><a class="header" href="#the-noir-programming-language">The Noir Programming Language</a></h1>
<p>This version of the book is being released with the public alpha.
There will be a lot of features that are missing in this version, however the syntax and the feel of the language will mostly be completed.</p>
<h2 id="what-is-noir"><a class="header" href="#what-is-noir">What is Noir?</a></h2>
<p>Noir is a domain specific language for creating and verifying proofs.
It's design choices are influenced heavily by Rust.</p>
<h2 id="whats-new-about-noir"><a class="header" href="#whats-new-about-noir">What's new about Noir?</a></h2>
<p>Noir is much more simple and flexible in design as it does not compile immediately to a fixed NP-complete language.
Instead Noir compiles to an intermediate language which itself can be compiled to an arithmetic circuit or a rank-1 constraint system.
This in itself brings up a few challenges within the design process, but allows one to decouple the programming language completely from the backend.
This is similar in theory to LLVM.</p>
<h2 id="who-is-noir-for"><a class="header" href="#who-is-noir-for">Who is Noir for?</a></h2>
<p>Noir can be used for a variety of purposes.</p>
<h3 id="ethereum-developers"><a class="header" href="#ethereum-developers">Ethereum Developers</a></h3>
<p>Noir currently includes a command to publish a contract which verifies your Noir program. This will be modularised in the future, however as of the alpha you can use the <code>contract</code> command to create it.</p>
<h3 id="protocol-developers"><a class="header" href="#protocol-developers">Protocol Developers</a></h3>
<p>As a protocol developer, you may not want to use the Aztec backend due to it not being a fit for your stack or maybe you simply want to use a different proving system.
Since Noir does not compile to a specific proof system, it is possible for protocol developers to replace the PLONK based proving system with a different proving system altogether.</p>
<h3 id="blockchain-developers"><a class="header" href="#blockchain-developers">Blockchain developers</a></h3>
<p>As a blockchain developer, you will be constrained by parameters set by your blockchain, ie the proving system and smart contract language has been pre-defined.
In order for you to use Noir in your blockchain, a proving system backend must be implemented for it and a smart contract interface must be implemented for it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>In this section we will discuss, installing Noir and running your first program.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nargo"><a class="header" href="#nargo">Nargo</a></h1>
<p><code>nargo</code> is a command line tool for interacting with Noir programs (e.g. compiling, proving, verifying and more).</p>
<p>Alternatively, the interactions can also be performed in <a href="getting_started/typescript.html">TypeScript</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<ol>
<li>
<p>Install <a href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git">Git</a> and <a href="https://www.rust-lang.org/tools/install">Rust</a>.</p>
<p>Optionally you can install <a href="https://marketplace.visualstudio.com/items?itemName=noir-lang.noir-programming-language-syntax-highlighter">Noir VS Code extension</a> for syntax highlighting as well.</p>
</li>
<li>
<p>Download Noir's source code from Github by running:</p>
<pre><code class="language-bash">$ git clone git@github.com:noir-lang/noir.git
</code></pre>
</li>
<li>
<p>Change directory into the nargo crate by running:</p>
<pre><code class="language-bash">$ cd noir/crates/nargo
</code></pre>
</li>
</ol>
<p>There are then two approaches to proceed, differing in how the proving backend is installed:</p>
<h2 id="option-1-wasm-executable-backend"><a class="header" href="#option-1-wasm-executable-backend">Option 1: WASM Executable Backend</a></h2>
<p><strong>Platforms Supported:</strong> Linux, macOS, Windows</p>
<ol start="4">
<li>
<p>Go into <code>nargo/Cargo.toml</code> and replace <code>aztec_backend = ...</code> with the following:</p>
<pre><code>aztec_backend = { optional = true, git = &quot;https://github.com/noir-lang/aztec_backend&quot;, features = [&quot;wasm-base&quot;] , default-features = false }
</code></pre>
</li>
</ol>
<blockquote>
<p><strong>Note:</strong> <code>nargo contract</code> has not been implemented yet for <em>wasm-base</em> <code>nargo</code> installations.</p>
</blockquote>
<h2 id="option-2-compile-backend-from-source"><a class="header" href="#option-2-compile-backend-from-source">Option 2: Compile Backend from Source</a></h2>
<p><strong>Platforms Supported:</strong> Linux, macOS</p>
<p>The <a href="https://github.com/AztecProtocol/aztec-connect/tree/master/barretenberg">barretenberg</a> proving backend is written in C++, hence compiling it from source would first require certain dependencies to be installed.</p>
<p>For macOS users, installing through <a href="https://brew.sh/">Homebrew</a> is highly recommended.</p>
<ol start="4">
<li>
<p>Install <a href="https://cmake.org/install/">CMake</a>, <a href="https://llvm.org/docs/GettingStarted.html">LLVM</a> and <a href="https://openmp.llvm.org/">OpenMP</a> by running:</p>
<!---
TODO: Supplement Linux scripts.

Linux's command for openMP from barretenberg's GitHub README:

```bash
RUN git clone -b release/10.x --depth 1 https://github.com/llvm/llvm-project.git \
&& cd llvm-project && mkdir build-openmp && cd build-openmp \
&& cmake ../openmp -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ -DLIBOMP_ENABLE_SHARED=OFF \
&& make -j$(nproc) \
&& make install \
&& cd ../.. && rm -rf llvm-project
```
--->
<p><em>macOS</em></p>
<pre><code class="language-bash">$ brew install cmake llvm libomp
</code></pre>
</li>
</ol>
<h2 id="continue-with-installation"><a class="header" href="#continue-with-installation">Continue with Installation</a></h2>
<ol start="5">
<li>
<p>Install nargo by running:</p>
<pre><code class="language-bash">$ cargo install --locked --path=.
</code></pre>
</li>
<li>
<p>Check if the installation was successful by running:</p>
<pre><code>$ nargo help
nargo 0.1
Kevaundray Wedderburn &lt;kevtheappdev@gmail.com&gt;
Noir's package manager

USAGE:
   nargo [SUBCOMMAND]

FLAGS:
   -h, --help       Prints help information
   -V, --version    Prints version information

SUBCOMMANDS:
   build       Builds the constraint system
   compile     Compile the program and its secret execution trace into ACIR format
   contract    Creates the smart contract code for circuit
   help        Prints this message or the help of the given subcommand(s)
   new         Create a new binary project
   prove       Create proof for this program
   verify      Given a proof and a program, verify whether the proof is valid
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<h2 id="nargo-help-subcommand"><a class="header" href="#nargo-help-subcommand"><code>nargo help [subcommand]</code></a></h2>
<p>Prints the list of available commands or specific information of a subcommand.</p>
<p><em>Arguments</em></p>
<ul>
<li><code>&lt;subcommand&gt;</code> - The subcommand whose help message to display</li>
</ul>
<h2 id="nargo-new-package_name-path"><a class="header" href="#nargo-new-package_name-path"><code>nargo new &lt;package_name&gt; [path]</code></a></h2>
<p>Creates a new Noir project.</p>
<p><em>Arguments</em></p>
<ul>
<li><code>&lt;package_name&gt;</code> - Name of the package</li>
<li><code>[path]</code> - The path to save the new project</li>
</ul>
<h2 id="nargo-build"><a class="header" href="#nargo-build"><code>nargo build</code></a></h2>
<p>Generate the <code>Prover.toml</code> and <code>Verifier.toml</code> files for specifying prover and verifier in/output values of the Noir program respectively.</p>
<h2 id="nargo-prove-proof_name"><a class="header" href="#nargo-prove-proof_name"><code>nargo prove &lt;proof_name&gt;</code></a></h2>
<p>Creates a proof for the program.</p>
<p><em>Arguments</em></p>
<ul>
<li><code>&lt;proof_name&gt;</code> - The name of the proof</li>
</ul>
<h2 id="nargo-verify-proof"><a class="header" href="#nargo-verify-proof"><code>nargo verify &lt;proof&gt;</code></a></h2>
<p>Given a proof and a program, verify whether the proof is valid.</p>
<p><em>Arguments</em></p>
<ul>
<li><code>&lt;proof&gt;</code> - The proof to verify</li>
</ul>
<h2 id="nargo-contract"><a class="header" href="#nargo-contract"><code>nargo contract</code></a></h2>
<p>Generate a Solidity smart contract verifier for the program.</p>
<h2 id="nargo-compile-flags-circuit_name"><a class="header" href="#nargo-compile-flags-circuit_name"><code>nargo compile [FLAGS] &lt;circuit_name&gt;</code></a></h2>
<p>Compile the program and its secret execution trace into <a href="getting_started/nargo/../../acir.html">ACIR</a> format.</p>
<p><em>Arguments</em></p>
<ul>
<li><code>&lt;circuit_name&gt;</code> - The name of the ACIR file</li>
<li><code>[FLAGS]</code> - Add <code>--witness</code> to compile the witness file as well</li>
</ul>
<p><em>Usage</em></p>
<p>Running the command would create a new folder <code>build</code> with the compiled <code>&lt;circuit_name&gt;.acir</code> file in your project directory.</p>
<p>To also compile a witness file, fill in the values in <code>Prover.toml</code> generated from <code>nargo build</code> and run the command with the <code>--witness</code> flag. A <code>&lt;circuit_name&gt;.tr</code> file would be compiled in the <code>build</code> folder.</p>
<blockquote>
<p><strong>Info:</strong> The <code>.acir</code> file is the ACIR of your Noir program, and the <code>.tr</code> file is the witness file. The witness file can be considered as program inputs parsed for your program's ACIR.</p>
<p>The files compiled can be passed into a TypeScript project for proving and verification. See the <a href="getting_started/nargo/../typescript.html#proving-and-verifying-externally-compiled-files">TypeScript</a> section to learn more.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello, World</a></h1>
<p>Now that we have installed Noir, it's time to make our first hello world program!</p>
<h2 id="creating-a-project-directory"><a class="header" href="#creating-a-project-directory">Creating a Project Directory</a></h2>
<p>Noir code can live anywhere on your computer. Lets create a Projects folder in the <code>Home</code> to house our Noir programs.</p>
<p>For Linux, macOS, and PowerShell on Windows, enter this in your terminal:</p>
<pre><code class="language-sh">$ mkdir ~/projects
$ cd ~/projects
</code></pre>
<p>For Windwows CMD, enter this:</p>
<pre><code class="language-sh">&gt; mkdir &quot;%USERPROFILE%\projects&quot;
&gt; cd /d &quot;%USERPROFILE%\projects&quot;
</code></pre>
<h2 id="compiling-our-first-project"><a class="header" href="#compiling-our-first-project">Compiling Our First Project</a></h2>
<p>Now that we are in the projects directory, enter the following command:</p>
<pre><code class="language-sh">$ nargo new hello_world
</code></pre>
<p>We use the <code>new</code> command to create a new Noir project. This project will be located in the <code>hello_world</code> folder.</p>
<p>Now <code>cd</code> into the <code>hello_world</code> folder and enter this:</p>
<pre><code>$ nargo build
</code></pre>
<p>Now that the project is built, we need to create a proof of correct execution.
Edit the file <code>Prover.toml</code> with the following content:</p>
<pre><code>x = &quot;1&quot;
y = &quot;2&quot;
</code></pre>
<p>and edit the <code>Verifier.toml</code> file with the following content:</p>
<pre><code>y = &quot;2&quot;
setpub = []
</code></pre>
<p>Now you can run the proof generation and verification commands:</p>
<pre><code>$ nargo prove my_proof
$ nargo verify my_proof
true
</code></pre>
<p>Congratulations, you have now created and verified a proof for your very first Noir program!</p>
<p>In the next section, we will go into more detail on exactly what just happened.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="breakdown"><a class="header" href="#breakdown">Breakdown</a></h1>
<p>This section breaks down our hello world program in section <em>1.2</em>.
We elaborate on the project structure and what the <code>prove</code> and <code>verify</code> commands did in the previous section, and usage of the <code>contract</code> command.</p>
<h2 id="anatomy-of-a-nargo-project"><a class="header" href="#anatomy-of-a-nargo-project">Anatomy of a Nargo Project</a></h2>
<p>Upon using the <code>new</code> command, Nargo will create a Noir project.</p>
<p>Noir Projects have the following structure:</p>
<pre><code>- src
- Prover.toml
- Verifier.toml
- Nargo.toml
</code></pre>
<p><em>contract</em> and <em>proofs</em> directories will not be immediately visible until you create a contract or proof respectively.</p>
<h3 id="source-directory"><a class="header" href="#source-directory">Source directory</a></h3>
<p>This directory holds the source code for your Noir program.</p>
<p>Inside of the src directory will be a single file:</p>
<pre><code>- main.nr
</code></pre>
<h4 id="mainnr"><a class="header" href="#mainnr">main.nr</a></h4>
<p>The main.nr file contains a <code>main</code> method, this method is the entry point into your Noir program.</p>
<p>In our sample program, main.nr looks like this:</p>
<pre><code>fn main(x : Field, y : Field) {
    constrain x != y;
}
</code></pre>
<p>The parameters <code>x</code> and <code>y</code> can be seen as the API for the program and must be supplied by the prover. Since neither <code>x</code> nor <code>y</code> is marked as public, the verifier does not supply any inputs, when verifying the proof.</p>
<p>The prover supplies the values for <code>x</code> and <code>y</code> in the <code>Prover.toml</code> file.</p>
<h4 id="provertoml"><a class="header" href="#provertoml">Prover.toml</a></h4>
<p>The Prover.toml file is a file which the prover uses to supply his witness values(both private and public).</p>
<p>In our hello world program the Prover.toml file looks like this:</p>
<pre><code class="language-toml">x = &quot;5&quot;
y = &quot;10&quot;
</code></pre>
<p>When the command <code>nargo prove my_proof</code> is executed, two processes happen:</p>
<ul>
<li>First, Noir creates a proof that <code>x</code> which holds the value of <code>5</code> and <code>y</code> which holds the value of <code>10</code> is not equal. This not equal constraint is due to the line <code>constrain x != y</code>.</li>
</ul>
<blockquote>
<p><strong>Note:</strong> We have not expanded on the meaning of the syntax <code>constrain x != y</code> as it is not the focus of this chapter.</p>
</blockquote>
<ul>
<li>Second, Noir creates and stores the proof of this statement in the <code>proofs</code> directory and names the proof file <code>my_proof</code>. Opening this file will display the proof in hex format.</li>
</ul>
<h2 id="verifying-a-proof"><a class="header" href="#verifying-a-proof">Verifying a Proof</a></h2>
<p>When the command <code>nargo verify my_proof</code> is executed, two processes happen:</p>
<ul>
<li>
<p>Noir checks in the <code>proofs</code> directory for a file called <code>my_proof</code></p>
</li>
<li>
<p>If that file is found, the proof's validity is checked.</p>
</li>
</ul>
<blockquote>
<p><strong>Note:</strong> The validity of the proof is linked to the current Noir program; if the program is changed and the verifier verifies the proof, it will fail because the proof is not valid for the <em>modified</em> Noir program.</p>
</blockquote>
<h2 id="contract"><a class="header" href="#contract">Contract</a></h2>
<p>This directory holds the compiled <em>Ethereum</em> contract for the current Noir program.
The contract is not automatically compiled when the <code>prove</code> or <code>verify</code> command is ran.
To compile execute the following:</p>
<blockquote>
<p><strong>Note:</strong> At the time of pre-alpha, Nargo supports only one backend which is Aztec-Barretenberg. This backend only allows you to compile from a Noir program to an Ethereum contract. It is possible for Noir to compile to another smart contract platform as long as the backend supplies an implementation.</p>
</blockquote>
<pre><code class="language-sh">$ nargo contract
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tornadocash"><a class="header" href="#tornadocash">TornadoCash</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript"><a class="header" href="#typescript">TypeScript</a></h1>
<p>Interactions with Noir programs can also be performed in TypeScript, which can come in handy when writing tests or when working in TypeScript-based projects like <a href="https://hardhat.org/">Hardhat</a>.</p>
<p>The following sections use the <a href="https://github.com/vezenovm/basic_mul_noir_example"><em>Standard Noir Example</em></a> as an example to dissect a typical Noir workflow in TypeScript, with specific focus on its:</p>
<ul>
<li>Test script <a href="https://github.com/vezenovm/basic_mul_noir_example/blob/master/test/1_mul.ts"><code>1_mul.ts</code></a></li>
<li>Noir program <a href="https://github.com/vezenovm/basic_mul_noir_example/blob/master/circuits/src/main.nr"><code>main.nr</code></a></li>
<li>Verifier contract generator script <a href="https://github.com/vezenovm/basic_mul_noir_example/blob/master/scripts/generate_sol_verifier.ts"><code>generate_sol_verifier.ts</code></a></li>
</ul>
<p>You are also welcome to revisit the full scripts <a href="https://github.com/vezenovm/basic_mul_noir_example/blob/master/test/1_mul.ts"><code>1_mul.ts</code></a> of <em>Standard Noir Example</em> and <a href="https://github.com/vezenovm/mastermind-noir/blob/master/test/mm.ts"><code>mm.ts</code></a> of <em>Mastermind in Noir</em> anytime for inspirations.</p>
<h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<p>Install <a href="https://classic.yarnpkg.com/lang/en/docs/install/">Yarn</a> and <a href="https://nodejs.org/en/download/">Node.js</a>.</p>
<p>Install Noir dependencies in your project by running:</p>
<pre><code class="language-bash">$ yarn add @noir-lang/noir_wasm @noir-lang/barretenberg @noir-lang/aztec_backend
</code></pre>
<p>And import the applicable functions into your TypeScript file by adding:</p>
<pre><code class="language-ts">// 1_mul.ts
import { compile, acir_from_bytes } from '@noir-lang/noir_wasm';
import { setup_generic_prover_and_verifier, create_proof, verify_proof, create_proof_with_witness } from '@noir-lang/barretenberg/dest/client_proofs';
import { packed_witness_to_witness, serialise_public_inputs, compute_witnesses } from '@noir-lang/aztec_backend';
</code></pre>
<h2 id="compiling"><a class="header" href="#compiling">Compiling</a></h2>
<p>To begin proving and verifying a Noir program, it first needs to be compiled by calling <code>noir_wasm</code>'s <code>compile</code> function:</p>
<pre><code class="language-ts">// 1_mul.ts
const compiled_program = compile(path.resolve(__dirname, &quot;../circuits/src/main.nr&quot;));
</code></pre>
<p>The <code>compiled_program</code> returned by the function contains the <a href="getting_started/../acir.html">ACIR</a> and the Application Binary Interface (ABI) of your Noir program. They shall be stored for proving your program later:</p>
<pre><code class="language-ts">// 1_mul.ts
let acir = compiled_program.circuit;
const abi = compiled_program.abi;
</code></pre>
<blockquote>
<p><strong>Note:</strong> Compiling with <code>noir_wasm</code> may lack some of the newer features that <code>nargo compile</code> offers. See the <a href="getting_started/typescript.html#proving-and-verifying-externally-compiled-files">Proving and Verifying Externally Compiled Files</a> section to learn more.</p>
</blockquote>
<h2 id="specifying-inputs"><a class="header" href="#specifying-inputs">Specifying Inputs</a></h2>
<p>Having obtained the compiled program, the program inputs shall then be specified in its ABI.</p>
<p><em>Standard Noir Example</em> is a program that multiplies input <code>x</code> with input <code>y</code> and returns the result:</p>
<pre><code class="language-noir"># main.nr
fn main(x: u32, y: pub u32) -&gt; pub u32 {
    let z = x * y;
    z
}
</code></pre>
<p>Hence, one valid scenario for proving could be <code>x = 3</code>, <code>y = 4</code> and <code>return = 12</code>:</p>
<pre><code class="language-ts">// 1_mul.ts
abi.x = 3;
abi.y = 4;
abi.return = 12;
</code></pre>
<blockquote>
<p><strong>Info:</strong> Return values are also required to be specified, as they are merely syntax sugar of inputs with equality constraints.</p>
</blockquote>
<blockquote>
<p><strong>Tip:</strong> To best protect the private inputs in your program (if applicable) from public knowledge, you should consider minimizing any passing around of inputs and deleting the inputs on the prover instance once the proof is created when designing your program.</p>
</blockquote>
<h2 id="initializing-prover--verifier"><a class="header" href="#initializing-prover--verifier">Initializing Prover &amp; Verifier</a></h2>
<p>Prior to proving and verifying, the prover and verifier have to first be initialized by calling <code>barretenberg</code>'s <code>setup_generic_prover_and_verifier</code> with your Noir program's ACIR:</p>
<pre><code class="language-ts">// 1_mul.ts
let [prover, verifier] = await setup_generic_prover_and_verifier(acir);
</code></pre>
<h2 id="proving"><a class="header" href="#proving">Proving</a></h2>
<p>The Noir program can then be executed and proved by calling <code>barretenberg</code>'s <code>create_proof</code> function:</p>
<pre><code class="language-ts">// 1_mul.ts
const proof = await create_proof(prover, acir, abi);
</code></pre>
<h2 id="verifying"><a class="header" href="#verifying">Verifying</a></h2>
<p>The <code>proof</code> obtained can be verified by calling <code>barretenberg</code>'s <code>verify_proof</code> function:</p>
<pre><code class="language-ts">// 1_mul.ts
const verified = await verify_proof(verifier, proof);
</code></pre>
<p>The function should return <code>true</code> if the entire process is working as intended, which can be asserted if you are writing a test script:</p>
<pre><code class="language-ts">// 1_mul.ts
expect(verified).eq(true);
</code></pre>
<h2 id="verifying-with-smart-contract"><a class="header" href="#verifying-with-smart-contract">Verifying with Smart Contract</a></h2>
<p>Alternatively, a verifier smart contract can be generated and used for verifying Noir proofs in TypeScript as well.</p>
<p>This could be useful if the Noir program is designed to be decentrally verified and/or make use of decentralized states and logics that is handled at the smart contract level.</p>
<p>To generate the verifier smart contract:</p>
<pre><code class="language-ts">// generate_sol_verifier.ts

// Imports
import { writeFileSync } from 'fs';

...

// Generate verifier contract
const sc = verifier.SmartContract();
syncWriteFile(&quot;../contracts/plonk_vk.sol&quot;, sc);

...

function syncWriteFile(filename: string, data: any) {
    writeFileSync(join(__dirname, filename), data, {
      flag: 'w',
    });
}
</code></pre>
<p>To verify a Noir proof using the verifier contract:</p>
<pre><code class="language-ts">// 1_mul.ts

// Imports
import { ethers } from &quot;hardhat&quot;;
import { Contract, ContractFactory, utils } from 'ethers';

...

// Deploy verifier contract
let Verifier: ContractFactory;
let verifierContract: Contract;

before(async () =&gt; {
    Verifier = await ethers.getContractFactory(&quot;TurboVerifier&quot;);
    verifierContract = await Verifier.deploy();
});

...

// Verify proof
const sc_verified = await verifierContract.verify(proof);
expect(sc_verified).eq(true)
</code></pre>
<h2 id="proving-and-verifying-externally-compiled-files"><a class="header" href="#proving-and-verifying-externally-compiled-files">Proving and Verifying Externally Compiled Files</a></h2>
<p>In some cases, <code>noir_wasm</code> may lack some of the newer features for compiling Noir programs due to separated upgrade workflows.</p>
<p>To benefit from the best of both worlds, a Noir program can be compiled with <code>nargo compile</code>, with the <code>.acir</code> and <code>.tr</code> files then passed into your TypeScript project for proving and verifying:</p>
<pre><code class="language-ts">// 1_mul.ts

// Parse acir
let acirByteArray = path_to_uint8array(path.resolve(__dirname, '../circuits/build/p.acir'));
let acir = acir_from_bytes(acirByteArray);

// Parse witness
let witnessByteArray = path_to_uint8array(path.resolve(__dirname, '../circuits/build/p.tr'));
const barretenberg_witness_arr = await packed_witness_to_witness(acir, witnessByteArray);

...

// Create proof
const proof = await create_proof_with_witness(prover, barretenberg_witness_arr);
</code></pre>
<blockquote>
<p><strong>Info:</strong> The <code>.acir</code> file is the ACIR of your Noir program, and the <code>.tr</code> file is the witness file. The witness file can be considered as program inputs parsed for your program's ACIR.</p>
</blockquote>
<p>See the <a href="getting_started/nargo/commands.html#nargo-compile-circuit_name">Commands</a> section to learn more about the <code>nargo compile</code> command.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-concepts"><a class="header" href="#language-concepts">Language Concepts</a></h1>
<p>In this chapter, we will go over the concepts that are being used in Noir. Specifically, we will learn about types, control flow, comments, functions and declarations.
For some concepts, we also explain the rationale as to why they were designed in this particular way. Recurring themes you will encounter in this section are <em>simplicity</em> and <em>safety</em>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutability"><a class="header" href="#mutability">Mutability</a></h1>
<p>Variables in noir can be declared mutable via the <code>mut</code> keyword.
Mutable variables can be reassigned to via
an assignment expression.</p>
<pre><code class="language-rust noplaypen">let x = 2;
x = 3; // error: x must be mutable to be assigned to

let mut y = 3;
let y = 4; // OK
</code></pre>
<p>The <code>mut</code> modifier can also apply to patterns:</p>
<pre><code class="language-rust noplaypen">let (a, mut b) = (1, 2);
a = 11; // error: a must be mutable to be assigned to
b = 12; // OK

let mut (c, d) = (3, 4);
c = 13; // OK
d = 14; // OK

// etc.
let MyStruct { x: mut y } = MyStruct { x: a }
// y is now in scope
</code></pre>
<p>Note that mutability in noir is local and everything is passed by value, so if a
called function mutates its parameters then the parent function will keep the old value of the parameters.</p>
<pre><code class="language-rust noplaypen">fn main() -&gt; Field {
    let x = 3;
    helper(x);
    x // x is still 3
}

fn helper(mut x: i32) {
    x = 4;
}
</code></pre>
<h3 id="why-only-local-mutability"><a class="header" href="#why-only-local-mutability">Why only local mutability?</a></h3>
<p>Witnesses in a proving system are immutable in nature.
Noir aims to <em>closely</em> mirror this setting without applying additional overhead to the user.
Modeling a mutable reference is not as straightforward as on conventional architectures and
would incur some possibly unexpected overhead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-types"><a class="header" href="#data-types">Data types</a></h1>
<p>Noir has several varieties of data types: the primitive <code>Field</code> type, integer types, <code>bool</code>, arrays, structs, and tuple types.</p>
<p>Although each value in a constraint system is fundamentally a field element, we add a layer of abstraction over this;
each value can be <em>concealed</em> (a private type) or <em>revealed</em> (a public type).</p>
<p>A <strong>private value</strong> is known only to the Prover, while, a <strong>public value</strong> is known by the Prover and Verifier.
All public and private values are primitive types, though individual
fields of a struct may also be marked private or public.</p>
<p>Note that the terms private and public when applied to a type (e.g. in <code>pub Field</code>) have a different meaning than when
applied to a function <code>pub fn foo() { ... }</code>.
The later is a visibility modifier familiar to those coming from existing
langauges, while the former can be thought of as a visibility modifier for the Verifier.
So a <code>pub Field</code> would be visible to the Verifier while a <code>Field</code> would not (private is the default modifier).</p>
<h2 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h2>
<p>Any of these types can be private (the default) or public (via a <code>pub</code> modifier).</p>
<p>Note that private types are also referred to as witnesses.</p>
<h4 id="field-type"><a class="header" href="#field-type">Field Type</a></h4>
<p>A field type corresponds to a native field type in the backend. Usually this is a (roughly) 256-bit integer.
This should generally be the default type reached for to solve problems. Using a smaller integer type like <code>u64</code> incurs
extra range constraints and so is less efficient rather than more.</p>
<pre><code class="language-rust noplaypen">fn main(x : Field, y : Field) {
    let z = x + y;
}
</code></pre>
<p><code>x</code>, <code>y</code> and <code>z</code> are witness types (private <code>Field</code>). Using the <code>let</code> keyword we derived a new witness <code>z</code> which is constrained to be equal to <code>x + y</code>.</p>
<h4 id="integer-type"><a class="header" href="#integer-type">Integer Type</a></h4>
<p>An integer type is a witness type which has been constrained using a range constraint.
The Noir front-end currently supports arbitrary sized integer types.</p>
<p>Below we show the integer type in action:</p>
<pre><code class="language-rust noplaypen">fn main(x : Field) {
    let y = x as u24;
}
</code></pre>
<p><code>x</code> and <code>y</code> are both private types (witnesses), however <code>y</code> is an integer type.
If <code>y</code> exceeds the range \([0,2^{24}-1]\) then any proof created will output false by the verifier.</p>
<blockquote>
<p><strong>Note:</strong> The Aztec backend supports even and odd sized integer types, so while using the Aztec backend, even sized integer types such as u32, u48, as well as odd sized integer types such as u5, u3 will produce proofs.</p>
</blockquote>
<h4 id="constants"><a class="header" href="#constants">Constants</a></h4>
<p>A constant type is a value that does not change per circuit instance. This is different to a witness which changes per proof.
If a constant type that is being used in your program is changed, then your circuit will also change.</p>
<p>Below we show how to declare a constant value:</p>
<pre><code class="language-rust noplaypen">fn main() {
    let a: const Field = 5;

    // `const Field` can also be inferred:
    let a = 5;
}
</code></pre>
<p>Note that variables declared as mutable may not be constants:</p>
<pre><code class="language-rust noplaypen">fn main() {
    // error: Cannot mark a const type as mutable - any mutation would remove its const-ness
    let mut a: const Field = 5;

    // a inferred as a private Field here
    let mut a = 5;
}
</code></pre>
<h4 id="global-constants"><a class="header" href="#global-constants">Global Constants</a></h4>
<p>Constants can also be global; however, they must be declared <code>const</code> and explicitly type annotated. They can then be used like any other constant inside functions. Global consts can also be used to specify array annotations for function parameters and can be imported from submodules. </p>
<pre><code class="language-rust noplaypen">const N: Field = 5;

fn main(x : Field, y : [Field; N]) {
    let res = x * N;

    constrain res == y[0];

    let res2 = x * mysubmodule::N;
    constrain res != res2;
}

mod mysubmodule {
    use dep::std;

    const N: Field = 10;

    fn my_helper() -&gt; const Field {
        let x = N;
        x
    }
}
</code></pre>
<h4 id="pub-modifier"><a class="header" href="#pub-modifier"><code>pub</code> Modifier</a></h4>
<p>A public type is a value that may change per circuit instance. Unlike Constants, changing a public value will not change the circuit.</p>
<pre><code class="language-rust noplaypen">fn main(x : pub Field) {

}
</code></pre>
<p>As of the beta release, public types can only be declared through parameters on <code>main</code>.
In the code, they are treated no differently to witness types.</p>
<blockquote>
<p><strong>Note:</strong> This behaviour and type will change in future releases, to catch a linearity bug in user code.</p>
</blockquote>
<h2 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h2>
<p>Noir also supports arrays, structs, and tuples whose elements may be public or private.</p>
<h4 id="arrays"><a class="header" href="#arrays">Arrays</a></h4>
<p>An array is a data structure which allows you to group together data types.
All values in an array must be of the same type (i.e., they're homogeneous).</p>
<pre><code class="language-rust noplaypen">fn main(x : Field, y : Field) {
    let my_arr = [x, y];
}
</code></pre>
<p>Note that currently Noir only supports arrays with integer or <code>Field</code> elements.</p>
<blockquote>
<p><strong>Example:</strong> An array of <code>Field</code> types cannot be grouped together with an array of integer types.</p>
</blockquote>
<h4 id="structs"><a class="header" href="#structs">Structs</a></h4>
<p>Structs can be used to group together multiple different types:</p>
<pre><code class="language-rust noplaypen">struct Operation {
    lhs: Field,
    opcode: u8,
    rhs: Field,
}

fn main() {
    let opcode = 3 as u8;

    // operation: Operation
    let operation = Operation {
        lhs: 0,
        rhs: 1,
        opcode,
    }

    let zero = operation.lhs;
}
</code></pre>
<p>Structs can also be destructured in a pattern, binding each field to a new variable:</p>
<pre><code class="language-rust noplaypen">fn main() {
    let Operation { lhs, rhs: the_rhs, opcode: _ } = get_operation();
    // lhs and the_rhs are now in scope
}
</code></pre>
<h4 id="tuples"><a class="header" href="#tuples">Tuples</a></h4>
<p>Noir also supports tuples, which can be thought of as anonymous structs with integers as field names.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let tuple = (1, 2);
    let (a, b) = tuple;

    let (c, d, mut (e, f)) = (3, 4, (5, 6));
}
</code></pre>
<p>Tuple fields can be accessed via destructuring as above or via member access syntax.
The first field name of a tuple is <code>0</code>, then <code>1</code> and so on:</p>
<pre><code>fn main() {
    // tuple: (const Field, const Field, const Field, const Field)
    let tuple = (5, 6, 7, 8);

    let five = tuple.0;
    let eight = tuple.3;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions in Noir follow the same semantics of Rust, though Noir does not support early returns.</p>
<p>To declare a function the <code>fn</code> keyword is used.</p>
<pre><code class="language-rust noplaypen">fn foo() {}
</code></pre>
<p>All parameters in a function must have a type and all types are known at compile time.
The parameter is pre-pended with a colon and the parameter type.
Multiple parameters are separated using a comma.</p>
<pre><code class="language-rust noplaypen">fn foo(x : Field, y : pub Field){}
</code></pre>
<p>The return type of a function can be stated by using the <code>-&gt;</code> arrow notation. The function below states that the foo function must return a <code>Field</code>. If the function returns no value, then the arrow is omitted.</p>
<pre><code class="language-rust noplaypen">fn foo(x : Field, y : pub Field) -&gt; Field {
    x + y
}
</code></pre>
<p>Note that a <code>return</code> keyword is unneeded in this case - the last expression in a function's body is returned.</p>
<h2 id="call-expressions"><a class="header" href="#call-expressions">Call Expressions</a></h2>
<p>Calling a function in Noir is executed by using the function name and passing in the necessary arguments.</p>
<p>Below we show how to call the <code>foo</code> function from the <code>main</code> function using a call expression:</p>
<pre><code class="language-rust noplaypen">fn main(x : Field, y : Field) {
    let z = foo(x);
}

fn foo(x : Field) -&gt; Field {
    x + x
}
</code></pre>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p>You can define methods in Noir on any struct type in scope.</p>
<pre><code class="language-rust noplaypen">struct MyStruct {
    foo: Field,
    bar: Field,
}

impl MyStruct {
    fn new(foo: Field) -&gt; MyStruct {
        MyStruct {
            foo,
            bar: 2,
        }
    }

    fn sum(self) -&gt; Field {
        self.foo + self.bar
    }
}

fn main() {
    let s = MyStruct::new(40);
    constrain s.sum() == 42;
}
</code></pre>
<p>Methods are just syntactic sugar for functions, so if we wanted to we could also call <code>sum</code> as follows:</p>
<pre><code class="language-rust noplaypen">constrain MyStruct::sum(s) == 42
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments"><a class="header" href="#comments">Comments</a></h1>
<p>A comment is a line in your codebase which the compiler ignores, however it can be read by programmers.</p>
<p>Here is a single line comment:</p>
<pre><code class="language-rust noplaypen">// This is a comment and is ignored
</code></pre>
<p><code>//</code> is used to tell the compiler to ignore the rest of the line.</p>
<p>Noir doesn't have multi-line comments, but you can emulate them via using <code>//</code> on each line</p>
<pre><code class="language-rust noplaypen">// This is a multi line
// comment, that is ignored by 
// the compiler
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<h2 id="loops"><a class="header" href="#loops">Loops</a></h2>
<p>Noir has one kind of loop: the <code>for</code> loop. <code>for</code> loops allow you to repeat a block of code multiple times.</p>
<p>The following block of code between the braces is run 10 times.</p>
<pre><code class="language-rust noplaypen">for i in 0..10 {
    // do something
}
</code></pre>
<h2 id="if-expressions"><a class="header" href="#if-expressions">If Expressions</a></h2>
<p>Noir supports <code>if-else</code> statements. The syntax is most similar to Rust's where it is not required for the statement's conditonal to be surrounded by parentheses.</p>
<pre><code class="language-rust noplaypen">let a = 0;
let mut x: u32 = 0;

if a == 0 {
    if a != 0 {
        x = 6;
    } else {
        x = 2;
    }
} else {
    x = 5;
    constrain x == 5;
}
constrain x == 2;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operations"><a class="header" href="#operations">Operations</a></h1>
<h2 id="table-of-supported-operations"><a class="header" href="#table-of-supported-operations">Table of Supported Operations</a></h2>
<table><thead><tr><th align="left">Operation</th><th align="center">Description</th><th align="right">Requirements</th></tr></thead><tbody>
<tr><td align="left">+</td><td align="center">Adds two concealed types together</td><td align="right">Types must be concealed</td></tr>
<tr><td align="left">-</td><td align="center">Subtracts two concealed types together</td><td align="right">Types must be concealed</td></tr>
<tr><td align="left">*</td><td align="center">Multiplies two concealed types together</td><td align="right">Types must be concealed</td></tr>
<tr><td align="left">/</td><td align="center">Divides two concealed types together</td><td align="right">Types must be concealed</td></tr>
<tr><td align="left">^</td><td align="center">XOR two concealed types together</td><td align="right">Types must be integer</td></tr>
<tr><td align="left">&amp;</td><td align="center">AND two concealed types together</td><td align="right">Types must be integer</td></tr>
<tr><td align="left">&lt;</td><td align="center">returns a bool if one value is less than the other</td><td align="right">Upper bound must have a known bit size</td></tr>
<tr><td align="left">&lt;=</td><td align="center">returns a bool if one value is less than or equal to the other</td><td align="right">Upper bound must have a known bit size</td></tr>
<tr><td align="left">&gt;</td><td align="center">returns a bool if one value is more than the other</td><td align="right">Upper bound must have a known bit size</td></tr>
<tr><td align="left">&gt;=</td><td align="center">returns a bool if one value is more than or equal to the other</td><td align="right">Upper bound must have a known bit size</td></tr>
<tr><td align="left">==</td><td align="center">returns a bool if one value is equal to the other</td><td align="right">Both types must not be constants</td></tr>
<tr><td align="left">!=</td><td align="center">returns a bool if one value is not equal to the other</td><td align="right">Both types must not be constants</td></tr>
</tbody></table>
<h3 id="predicate-operators"><a class="header" href="#predicate-operators">Predicate Operators</a></h3>
<p><code>&lt;,&lt;=, !=, == , &gt;, &gt;=</code> are known as predicate/comparison operations because they compare two values. This differs from the operations such as <code>+</code> where the operands are used in <em>computation</em>.</p>
<h3 id="bitwise-operations-example"><a class="header" href="#bitwise-operations-example">Bitwise Operations Example</a></h3>
<pre><code class="language-rust noplaypen">fn main(x : Field) {
    let y = x as u32;
    let z = y &amp; y;
}
</code></pre>
<p><code>z</code> is implicitly constrained to be the result of <code>y &amp; y</code>. The <code>&amp;</code> operand is used to denote bitwise <code>&amp;</code>.</p>
<blockquote>
<p><code>x &amp; x</code> would not compile as <code>x</code> is a <code>Field</code> and not an integer type.</p>
</blockquote>
<h3 id="logical-operators"><a class="header" href="#logical-operators">Logical Operators</a></h3>
<p>Noir has no support for the logical operators <code>||</code> and <code>&amp;&amp;</code>.
This is because encoding the short-circuiting that these operators require can be inefficient for Noir's backend.
Instead you can use the bitwise operators <code>|</code> and <code>&amp;</code> which operate indentically for booleans, just without the short-circuiting.</p>
<pre><code class="language-rust noplaypen">let my_val = 5;

let mut flag = 1;
if (my_val &gt; 6) | (my_val == 0) {
    flag = 0;
}
constrain flag == 1;

if (my_val != 10) &amp; (my_val &lt; 50) {
    flag = 0;
}
constrain flag == 0;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constrain-statement"><a class="header" href="#constrain-statement">Constrain Statement</a></h1>
<p>Noir includes a special keyword <code>constrain</code> which will explicitly constrain the predicate/comparison expression that follows to be true.
If this expression is false at runtime, the program will fail to be proven.</p>
<h3 id="constrain-statement-example"><a class="header" href="#constrain-statement-example">Constrain statement example</a></h3>
<pre><code class="language-rust noplaypen">fn main(x : Field, y : Field) {
    constrain x == y
}
</code></pre>
<p>The above snippet compiles because <code>==</code> is a predicate operation. Conversely, the following will not compile:</p>
<pre><code class="language-rust noplaypen">fn main(x : Field, y : Field) {
    constrain x + y
}
</code></pre>
<blockquote>
<p>The rationale behind this not compiling is due to ambiguity. It is not clear if the above should equate to <code>x + y == 0</code> or if it should check the truthiness of the result.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules-packages-crates"><a class="header" href="#modules-packages-crates">Modules, Packages, Crates</a></h1>
<p>In this section, we describe the package, crate and module system. As mentioned in the introduction, this will largely follow the design choice chosen by Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crate"><a class="header" href="#crate">Crate</a></h1>
<p>A crate is the compilation unit used in Noir.</p>
<h2 id="crate-root"><a class="header" href="#crate-root">Crate Root</a></h2>
<p>Every crate has a root, which is the source file that the compiler starts, this is also known as the root module.
The Noir compiler does not enforce any conditions on the name of the file which is the crate root, however if you are compiling via Nargo.
The Crate Root, must be called <code>lib.nr</code> or <code>main.nr</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packages"><a class="header" href="#packages">Packages</a></h1>
<p>A Nargo Package is a collection of one of more crates. A Package must include a Nargo.toml file.</p>
<p>A Package <em>must</em> contain either a library or a binary crate.</p>
<h2 id="creating-a-new-package"><a class="header" href="#creating-a-new-package">Creating a new package</a></h2>
<p>A new package is created using the <code>new</code> command.</p>
<pre><code>$ nargo new my-project
$ ls my-project
Nargo.toml
src
$ ls my-project/src
main.nr
</code></pre>
<h2 id="binary-vs-library"><a class="header" href="#binary-vs-library">Binary vs Library</a></h2>
<p>Similar to Cargo, Nargo follows the convention that if there is a <code>src/main.nr</code> then the project is a binary. If it contains a <code>src/lib.nr</code> then it is a library.</p>
<p>However, note that dissimilar to Cargo, we cannot have both a binary and library in the same project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>Noir's module system follows the same convention as the <em>newer</em> version of Rust's module system.</p>
<h2 id="purpose-of-modules"><a class="header" href="#purpose-of-modules">Purpose of Modules</a></h2>
<p>Modules are used to organise files. Without modules all of your code would need to live in a single file. In Noir, the compiler does not automatically scan all of your files to detect modules. This must be done explicitly by the developer.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="importing-a-module-in-the-crate-root"><a class="header" href="#importing-a-module-in-the-crate-root">Importing a module in the crate root</a></h3>
<p>Filename : <code>src/main.nr</code></p>
<pre><code class="language-rust noplaypen">mod foo;

fn main() {
    foo::hello_world();
}
</code></pre>
<p>Filename : <code>src/foo.nr</code></p>
<pre><code class="language-rust noplaypen">fn from_foo() {}
</code></pre>
<p>In the above snippet, the crate root is the <code>src/main.nr</code> file.
The compiler sees the module declaration <code>mod foo</code> which prompts it to look for a foo.nr file.</p>
<p>Visually this module hierarchy looks like the following :</p>
<pre><code>crate
  main
 
  foo
       from_foo
      
</code></pre>
<h3 id="sub-modules"><a class="header" href="#sub-modules">Sub-modules</a></h3>
<p>Filename : <code>src/main.nr</code></p>
<pre><code class="language-rust noplaypen">mod foo;

fn main() {
    foo::from_foo();
}
</code></pre>
<p>Filename : <code>src/foo.nr</code></p>
<pre><code class="language-rust noplaypen">mod bar;
fn from_foo() {}
</code></pre>
<p>Filename : <code>src/foo/bar.nr</code></p>
<pre><code class="language-rust noplaypen">fn from_bar() {}
</code></pre>
<p>In the above snippet, we have added an extra module to the module tree; <code>bar</code>. <code>bar</code> is a submodule of <code>foo</code> hence we declare bar in <code>foo.nr</code> with <code>mod bar</code>. Since <code>foo</code> is not the crate root, the compiler looks for the file associated with the <code>bar</code> module in <code>src/foo/bar.nr</code></p>
<p>Visually the module hierarchy looks as follows:</p>
<pre><code>crate
  main
 
  foo
       from_foo
       bar
            from_bar
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h1>
<p>Nargo allows you to upload packages to GitHub and use them as dependencies.</p>
<h2 id="specifying-a-dependency"><a class="header" href="#specifying-a-dependency">Specifying a dependency</a></h2>
<pre><code>hello_world = { tag = &quot;v0.5&quot;, git = &quot;https://github.com/kevaundray/hello-world-noir&quot;}
</code></pre>
<p>Specifying a dependency requires a tag to a specific commit and the git url to the url containing the package.</p>
<p>Currently, there are no requirements on the tag contents. If requirements are added, it would follow semver 2.0 guidelines.</p>
<blockquote>
<p>Note: Without a <code>tag</code> , there would be no versioning and dependencies would change each time you compile your project.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="acir-abstract-circuit-intermediate-representation"><a class="header" href="#acir-abstract-circuit-intermediate-representation">ACIR (Abstract Circuit Intermediate Representation)</a></h2>
<p>The purpose of ACIR is to act as an intermediate layer between the proof system that Noir chooses to compile to and the Noir syntax.
This separation between proof system and programming language, allows those who want to integrate proof systems to have a stable target, moreover it allows the frontend to compile to any ACIR compatible proof system.</p>
<p>ACIR additionally allows proof systems to supply a fixed list of optimised blackbox functions that the frontend can access. Examples of this would be SHA256, PEDERSEN and SCHNORRSIGVERIFY.</p>
<h2 id="compiling-a-proof"><a class="header" href="#compiling-a-proof">Compiling a Proof</a></h2>
<p>When inside of a given Noir project the command <code>nargo compile my_proof</code> will perform two processes.</p>
<ul>
<li>
<p>First, compile the Noir program to its ACIR and solve the circuit's witness. </p>
</li>
<li>
<p>Second, create a new <code>build/</code> directory to store the ACIR, <code>my_proof.acir</code>, and the solved witness, <code>my_proof.tr</code></p>
</li>
</ul>
<p>These can be used by the Noir Typescript wrapper to generate a prover and verifier inside of Typescript rather than in Nargo. This will be discussed further in another section.</p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="./acir_diagram.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features-coming-soon"><a class="header" href="#features-coming-soon">Features Coming Soon</a></h1>
<h3 id="isize"><a class="header" href="#isize">Isize</a></h3>
<p>Signed integers such as i32 and i64 allow one to express more circuits. They are partially supported but need to be finalised. </p>
<h3 id="recursion"><a class="header" href="#recursion">Recursion</a></h3>
<p>Recursion is becoming feasible in circuits, hence Noir will have native support for it. Currently, only composition is supported. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="license"><a class="header" href="#license">LICENSE</a></h1>
<p>Noir will be dual licensed under MIT/Apache (Version 2.0).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
                
    </body>
</html>
