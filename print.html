<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Noir Programming Language</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
                <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">The Noir Programming Language</a></li><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started/nargo.html"><strong aria-hidden="true">1.1.</strong> Nargo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started/nargo/installation.html"><strong aria-hidden="true">1.1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="getting_started/nargo/commands.html"><strong aria-hidden="true">1.1.2.</strong> Commands</a></li></ol></li><li class="chapter-item expanded "><a href="getting_started/hello_world.html"><strong aria-hidden="true">1.2.</strong> Hello, World</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started/breakdown.html"><strong aria-hidden="true">1.2.1.</strong> Breakdown</a></li></ol></li><li class="chapter-item expanded "><a href="getting_started/solidity_verifier.html"><strong aria-hidden="true">1.3.</strong> Solidity Verifier</a></li><li class="chapter-item expanded "><a href="getting_started/typescript.html"><strong aria-hidden="true">1.4.</strong> TypeScript</a></li><li class="chapter-item expanded "><a href="getting_started/merkle-proof.html"><strong aria-hidden="true">1.5.</strong> Merkle Proof</a></li><li class="chapter-item expanded "><a href="getting_started/testing.html"><strong aria-hidden="true">1.6.</strong> Testing</a></li></ol></li><li class="chapter-item expanded "><a href="language_concepts.html"><strong aria-hidden="true">2.</strong> Language Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language_concepts/mutability.html"><strong aria-hidden="true">2.1.</strong> Mutability</a></li><li class="chapter-item expanded "><a href="language_concepts/data_types.html"><strong aria-hidden="true">2.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="language_concepts/functions.html"><strong aria-hidden="true">2.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="language_concepts/comments.html"><strong aria-hidden="true">2.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="language_concepts/control_flow.html"><strong aria-hidden="true">2.5.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="language_concepts/ops.html"><strong aria-hidden="true">2.6.</strong> Operations</a></li><li class="chapter-item expanded "><a href="language_concepts/constrain.html"><strong aria-hidden="true">2.7.</strong> Constrain Statement</a></li><li class="chapter-item expanded "><a href="standard_library.html"><strong aria-hidden="true">2.8.</strong> Standard Library (std)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="standard_library/logging.html"><strong aria-hidden="true">2.8.1.</strong> Logging</a></li><li class="chapter-item expanded "><a href="standard_library/field_methods.html"><strong aria-hidden="true">2.8.2.</strong> Fields</a></li><li class="chapter-item expanded "><a href="standard_library/array_methods.html"><strong aria-hidden="true">2.8.3.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="standard_library/merkle_trees.html"><strong aria-hidden="true">2.8.4.</strong> Merkle Trees</a></li><li class="chapter-item expanded "><a href="standard_library/cyptographic_primitives.html"><strong aria-hidden="true">2.8.5.</strong> Cryptographic Primitives</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="modules_packages_crates.html"><strong aria-hidden="true">3.</strong> Modules, Packages, Crates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="modules_packages_crates/crates_and_packages.html"><strong aria-hidden="true">3.1.</strong> Crates and Packages</a></li><li class="chapter-item expanded "><a href="modules_packages_crates/modules.html"><strong aria-hidden="true">3.2.</strong> Modules</a></li><li class="chapter-item expanded "><a href="modules_packages_crates/dependencies.html"><strong aria-hidden="true">3.3.</strong> Dependencies</a></li></ol></li><li class="chapter-item expanded "><a href="acir.html"><strong aria-hidden="true">4.</strong> ACIR</a></li><li class="chapter-item expanded "><a href="c_overview.html"><strong aria-hidden="true">5.</strong> Compilation Overview</a></li><li class="chapter-item expanded "><a href="coming_soon.html"><strong aria-hidden="true">6.</strong> Coming!</a></li><li class="chapter-item expanded "><a href="license.html"><strong aria-hidden="true">7.</strong> LICENSE</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Noir Programming Language</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-noir-programming-language"><a class="header" href="#the-noir-programming-language">The Noir Programming Language</a></h1>
<p>This version of the book is being released with the public alpha.
There will be a lot of features that are missing in this version, however the syntax and the feel of the language will mostly be completed.</p>
<h2 id="what-is-noir"><a class="header" href="#what-is-noir">What is Noir?</a></h2>
<p>Noir is a domain specific language for creating and verifying proofs.
It's design choices are influenced heavily by Rust.</p>
<h2 id="whats-new-about-noir"><a class="header" href="#whats-new-about-noir">What's new about Noir?</a></h2>
<p>Noir is much more simple and flexible in design as it does not compile immediately to a fixed NP-complete language.
Instead Noir compiles to an intermediate language which itself can be compiled to an arithmetic circuit or a rank-1 constraint system.
This in itself brings up a few challenges within the design process, but allows one to decouple the programming language completely from the backend.
This is similar in theory to LLVM.</p>
<h2 id="who-is-noir-for"><a class="header" href="#who-is-noir-for">Who is Noir for?</a></h2>
<p>Noir can be used for a variety of purposes.</p>
<h3 id="ethereum-developers"><a class="header" href="#ethereum-developers">Ethereum Developers</a></h3>
<p>Noir currently includes a command to publish a contract which verifies your Noir program. This will be modularised in the future, however as of the alpha you can use the <code>contract</code> command to create it.</p>
<h3 id="protocol-developers"><a class="header" href="#protocol-developers">Protocol Developers</a></h3>
<p>As a protocol developer, you may not want to use the Aztec backend due to it not being a fit for your stack or maybe you simply want to use a different proving system.
Since Noir does not compile to a specific proof system, it is possible for protocol developers to replace the PLONK based proving system with a different proving system altogether.</p>
<h3 id="blockchain-developers"><a class="header" href="#blockchain-developers">Blockchain developers</a></h3>
<p>As a blockchain developer, you will be constrained by parameters set by your blockchain, ie the proving system and smart contract language has been pre-defined.
In order for you to use Noir in your blockchain, a proving system backend must be implemented for it and a smart contract interface must be implemented for it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>In this section we will discuss, installing Noir and running your first program.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nargo"><a class="header" href="#nargo">Nargo</a></h1>
<p><code>nargo</code> is a command line tool for interacting with Noir programs (e.g. compiling, proving, verifying and more).</p>
<p>Alternatively, the interactions can also be performed in <a href="getting_started/typescript.html">TypeScript</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>There are two approaches to install Nargo:</p>
<ul>
<li><a href="getting_started/nargo/installation.html#option-1-binaries">Option 1: Binaries</a></li>
<li><a href="getting_started/nargo/installation.html#option-2-compile-from-source">Option 2: Compile from Source</a></li>
</ul>
<p>Optionally you can also install <a href="https://marketplace.visualstudio.com/items?itemName=noir-lang.noir-programming-language-syntax-highlighter">Noir VS Code extension</a> for syntax highlighting.</p>
<h2 id="option-1-binaries"><a class="header" href="#option-1-binaries">Option 1: Binaries</a></h2>
<h3 id="step-1"><a class="header" href="#step-1">Step 1</a></h3>
<p>Paste and run the following in the terminal to extract and install the binary:</p>
<blockquote>
<p><strong>macOS / Linux:</strong> If you are prompted with <code>Permission denied</code> when running commands, prepend <code>sudo</code> and re-run it.</p>
</blockquote>
<h4 id="macos-apple-silicon"><a class="header" href="#macos-apple-silicon">macOS (Apple Silicon)</a></h4>
<pre><code class="language-bash">mkdir -p $HOME/.nargo/bin &amp;&amp; \
curl -o $HOME/.nargo/bin/nargo-aarch64-apple-darwin.tar.gz -L https://github.com/noir-lang/noir/releases/download/nightly/nargo-aarch64-apple-darwin.tar.gz &amp;&amp; \
tar -xvf $HOME/.nargo/bin/nargo-aarch64-apple-darwin.tar.gz -C $HOME/.nargo/bin/ &amp;&amp; \
echo '\nexport PATH=$PATH:$HOME/.nargo/bin' &gt;&gt; ~/.zshrc &amp;&amp; \
source ~/.zshrc
</code></pre>
<h4 id="macos-intel"><a class="header" href="#macos-intel">macOS (Intel)</a></h4>
<pre><code class="language-bash">mkdir -p $HOME/.nargo/bin &amp;&amp; \
curl -o $HOME/.nargo/bin/nargo-x86_64-apple-darwin.tar.gz -L https://github.com/noir-lang/noir/releases/download/nightly/nargo-x86_64-apple-darwin.tar.gz &amp;&amp; \
tar -xvf $HOME/.nargo/bin/nargo-x86_64-apple-darwin.tar.gz -C $HOME/.nargo/bin/ &amp;&amp; \
echo '\nexport PATH=$PATH:$HOME/.nargo/bin' &gt;&gt; ~/.zshrc &amp;&amp; \
source ~/.zshrc
</code></pre>
<h4 id="windows-powershell"><a class="header" href="#windows-powershell">Windows (PowerShell)</a></h4>
<p>Open PowerShell as Administrator and run:</p>
<pre><code class="language-sh">mkdir -f -p &quot;$env:USERPROFILE\.nargo\bin\&quot;; `
Invoke-RestMethod -Method Get -Uri https://github.com/noir-lang/noir/releases/download/nightly/nargo-x86_64-pc-windows-msvc.zip -Outfile &quot;$env:USERPROFILE\.nargo\bin\nargo-x86_64-pc-windows-msvc.zip&quot;; `
Expand-Archive -Path &quot;$env:USERPROFILE\.nargo\bin\nargo-x86_64-pc-windows-msvc.zip&quot; -DestinationPath &quot;$env:USERPROFILE\.nargo\bin\&quot;; `
$Reg = &quot;Registry::HKLM\System\CurrentControlSet\Control\Session Manager\Environment&quot;; `
$OldPath = (Get-ItemProperty -Path &quot;$Reg&quot; -Name PATH).Path; `
$NewPath = $OldPath + ’;’ + &quot;$env:USERPROFILE\.nargo\bin\&quot;; `
Set-ItemProperty -Path &quot;$Reg&quot; -Name PATH –Value &quot;$NewPath&quot;; `
$env:Path = [System.Environment]::GetEnvironmentVariable(&quot;Path&quot;,&quot;Machine&quot;) + &quot;;&quot; + [System.Environment]::GetEnvironmentVariable(&quot;Path&quot;,&quot;User&quot;)
</code></pre>
<h4 id="linux-bash"><a class="header" href="#linux-bash">Linux (Bash)</a></h4>
<p>See <a href="https://github.com/noir-lang/noir/releases/tag/nightly">GitHub Releases</a> for additional platform specific binaries.</p>
<pre><code class="language-bash">mkdir -p $HOME/.nargo/bin &amp;&amp; \
curl -o $HOME/.nargo/bin/nargo-x86_64-unknown-linux-gnu.tar.gz -L https://github.com/noir-lang/noir/releases/download/nightly/nargo-x86_64-unknown-linux-gnu.tar.gz &amp;&amp; \
tar -xvf $HOME/.nargo/bin/nargo-x86_64-unknown-linux-gnu.tar.gz -C $HOME/.nargo/bin/ &amp;&amp; \
echo '\nexport PATH=$PATH:$HOME/.nargo/bin' &gt;&gt; ~/.bashrc &amp;&amp; \
source ~/.bashrc
</code></pre>
<h3 id="step-2"><a class="header" href="#step-2">Step 2</a></h3>
<p>Check if the installation was successful by running <code>nargo --help</code>.</p>
<blockquote>
<p><strong>macOS:</strong> If you are prompted with an OS alert, right-click and open the <em>nargo</em> executable from Finder. Close the new terminal popped up and <code>nargo</code> should now be accessible.</p>
</blockquote>
<p>For a successful installation, you should see something similar to the following after running the command:</p>
<pre><code>$ nargo --help
Noir's package manager

Usage: nargo &lt;COMMAND&gt;

Commands:
  check             Checks the constraint system for errors
  codegen-verifier  Generates a Solidity verifier smart contract for the program
  compile           Compile the program and its secret execution trace into ACIR format
  new               Create a new binary project
  execute           Executes a circuit to calculate its return value
  prove             Create proof for this program. The proof is returned as a hex encoded string
  verify            Given a proof and a program, verify whether the proof is valid
  test              Run the tests for this program
  gates             Counts the occurrences of different gates in circuit
  help              Print this message or the help of the given subcommand(s)
</code></pre>
<h2 id="option-2-compile-from-source"><a class="header" href="#option-2-compile-from-source">Option 2: Compile from Source</a></h2>
<h3 id="setup"><a class="header" href="#setup">Setup</a></h3>
<ol>
<li>
<p>Install <a href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git">Git</a> and <a href="https://www.rust-lang.org/tools/install">Rust</a>.</p>
</li>
<li>
<p>Download Noir's source code from Github by running:</p>
<pre><code class="language-bash">git clone git@github.com:noir-lang/noir.git
</code></pre>
</li>
<li>
<p>Change directory into the Noir project by running:</p>
<pre><code class="language-bash">cd noir
</code></pre>
</li>
</ol>
<p>There are then two approaches to proceed, differing in how the proving backend is installed:</p>
<h3 id="option-21-install-executable-with-wasm-backend"><a class="header" href="#option-21-install-executable-with-wasm-backend">Option 2.1: Install Executable with WASM backend</a></h3>
<ol start="4">
<li>
<p>Install Nargo by running:</p>
<pre><code class="language-bash">cargo install --locked --path=crates/nargo --no-default-features --features plonk_bn254_wasm
</code></pre>
</li>
</ol>
<h3 id="option-22-install-executable-with-native-backend"><a class="header" href="#option-22-install-executable-with-native-backend">Option 2.2: Install Executable with Native Backend</a></h3>
<p>The <a href="https://github.com/AztecProtocol/barretenberg">barretenberg</a> proving backend is written in C++, hence compiling it from source would first require certain dependencies to be installed.</p>
<ol start="4">
<li>
<p>Install <a href="https://cmake.org/install/">CMake</a>, <a href="https://llvm.org/docs/GettingStarted.html">LLVM</a> and <a href="https://openmp.llvm.org/">OpenMP</a>:</p>
<h4 id="macos"><a class="header" href="#macos">macOS</a></h4>
<p>Installing through <a href="https://brew.sh/">Homebrew</a> is recommended:</p>
<pre><code class="language-bash">brew install cmake llvm libomp
</code></pre>
<h4 id="ubuntu-linux"><a class="header" href="#ubuntu-linux">Ubuntu (Linux)</a></h4>
<pre><code class="language-bash">sudo apt update &amp;&amp; sudo apt install clang lld cmake libomp-dev
</code></pre>
<p>Other variants of Linux will need to adjust the commands for their package manager.</p>
<h4 id="windows"><a class="header" href="#windows">Windows</a></h4>
<pre><code class="language-sh">TBC
</code></pre>
</li>
<li>
<p>Install Nargo by running:</p>
<pre><code class="language-bash">cargo install --locked --path=crates/nargo
</code></pre>
</li>
</ol>
<h3 id="verify-installation"><a class="header" href="#verify-installation">Verify Installation</a></h3>
<ol start="6">
<li>
<p>Check if the installation was successful by running <code>nargo --help</code>:</p>
<pre><code>$ nargo --help
Noir's package manager

Usage: nargo &lt;COMMAND&gt;

Commands:
  check             Checks the constraint system for errors
  codegen-verifier  Generates a Solidity verifier smart contract for the program
  compile           Compile the program and its secret execution trace into ACIR format
  new               Create a new binary project
  execute           Executes a circuit to calculate its return value
  prove             Create proof for this program. The proof is returned as a hex encoded string
  verify            Given a proof and a program, verify whether the proof is valid
  test              Run the tests for this program
  gates             Counts the occurrences of different gates in circuit
  help              Print this message or the help of the given subcommand(s)
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<h2 id="nargo-help-subcommand"><a class="header" href="#nargo-help-subcommand"><code>nargo help [subcommand]</code></a></h2>
<p>Prints the list of available commands or specific information of a subcommand.</p>
<p><em>Arguments</em></p>
<ul>
<li><code>&lt;subcommand&gt;</code> - The subcommand whose help message to display</li>
</ul>
<h2 id="nargo-new-package_name-path"><a class="header" href="#nargo-new-package_name-path"><code>nargo new &lt;package_name&gt; [path]</code></a></h2>
<p>Creates a new Noir project.</p>
<p><em>Arguments</em></p>
<ul>
<li><code>&lt;package_name&gt;</code> - Name of the package</li>
<li><code>[path]</code> - The path to save the new project</li>
</ul>
<h2 id="nargo-check"><a class="header" href="#nargo-check"><code>nargo check</code></a></h2>
<p>Generate the <code>Prover.toml</code> and <code>Verifier.toml</code> files for specifying prover and verifier in/output values of the Noir program respectively.</p>
<h2 id="nargo-compile-circuit_name"><a class="header" href="#nargo-compile-circuit_name"><code>nargo compile &lt;circuit_name&gt;</code></a></h2>
<p>Compile the program into a JSON build artifact file containing the ACIR representation and the ABI of the circuit. This build artifact can then be used to generate and verify proofs.</p>
<p><em>Arguments</em></p>
<ul>
<li><code>&lt;circuit_name&gt;</code> - The name of the circuit file</li>
</ul>
<h2 id="nargo-execute-witness_name"><a class="header" href="#nargo-execute-witness_name"><code>nargo execute [witness_name]</code></a></h2>
<p>Runs the Noir program and prints its return value.</p>
<p><em>Arguments</em></p>
<ul>
<li><code>[witness_name]</code> - The name of the witness</li>
</ul>
<p><em>Usage</em></p>
<p>The inputs to the circuit are read from the <code>Prover.toml</code> file generated by <code>nargo check</code>, which must be filled in.</p>
<p>To save the witness to file, run the command with a value for the <code>witness-name</code> argument. A <code>&lt;witness_name-name&gt;.tr</code> file will then be saved in the <code>build</code> folder.</p>
<blockquote>
<p><strong>Info:</strong> The <code>.tr</code> file is the witness file. The witness file can be considered as program inputs parsed for your program's ACIR.</p>
<p>This file can be passed along with circuit's ACIR into a TypeScript project for proving and verification. See the <a href="getting_started/nargo/../typescript.html#proving-and-verifying-externally-compiled-files">TypeScript</a> section to learn more.</p>
</blockquote>
<h2 id="nargo-prove-proof_name"><a class="header" href="#nargo-prove-proof_name"><code>nargo prove &lt;proof_name&gt;</code></a></h2>
<p>Creates a proof for the program.</p>
<p><em>Arguments</em></p>
<ul>
<li><code>&lt;proof_name&gt;</code> - The name of the proof</li>
</ul>
<h2 id="nargo-verify-proof"><a class="header" href="#nargo-verify-proof"><code>nargo verify &lt;proof&gt;</code></a></h2>
<p>Given a proof and a program, verify whether the proof is valid.</p>
<p><em>Arguments</em></p>
<ul>
<li><code>&lt;proof&gt;</code> - The proof to verify</li>
</ul>
<h2 id="nargo-codegen-verifier"><a class="header" href="#nargo-codegen-verifier"><code>nargo codegen-verifier</code></a></h2>
<p>Generate a Solidity verifier smart contract for the program.</p>
<h2 id="nargo-preprocess-build_artifact"><a class="header" href="#nargo-preprocess-build_artifact"><code>nargo preprocess &lt;build_artifact&gt;</code></a></h2>
<p>Generate proving and verification keys from a build artifact file.</p>
<h2 id="nargo-test-pattern"><a class="header" href="#nargo-test-pattern"><code>nargo test &lt;pattern&gt;</code></a></h2>
<p>Nargo will automatically compile and run any functions which have the decorator <code>#[test]</code> on them if you run <code>nargo test</code>.</p>
<p>See an example on the <a href="getting_started/nargo/../testing.html">testing page</a>.</p>
<p><em>Arguments</em></p>
<ul>
<li><code>&lt;pattern&gt;</code> - a pattern to indicate to only run tests with names containing the pattern</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello, World</a></h1>
<p>Now that we have installed Nargo, it is time to make our first hello world program!</p>
<h2 id="create-a-project-directory"><a class="header" href="#create-a-project-directory">Create a Project Directory</a></h2>
<p>Noir code can live anywhere on your computer. Let us create a <em>projects</em> folder in the home directory to house our Noir programs.</p>
<p>For Linux, macOS, and Windows PowerShell, create the directory and change directory into it by running:</p>
<pre><code class="language-sh">$ mkdir ~/projects
$ cd ~/projects
</code></pre>
<p>For Windwows CMD, run:</p>
<pre><code class="language-sh">&gt; mkdir &quot;%USERPROFILE%\projects&quot;
&gt; cd /d &quot;%USERPROFILE%\projects&quot;
</code></pre>
<h2 id="create-our-first-nargo-project"><a class="header" href="#create-our-first-nargo-project">Create Our First Nargo Project</a></h2>
<p>Now that we are in the projects directory, create a new Nargo project by running:</p>
<pre><code class="language-sh">$ nargo new hello_world
</code></pre>
<blockquote>
<p><strong>Note:</strong> <code>hello_world</code> can be any arbitrary project name, we are simply using <code>hello_world</code> for demonstration.</p>
<p>In production, the common practice is to name the project folder as <code>circuits</code> for better identifiability when sitting alongside other folders in the codebase (e.g. <code>contracts</code>, <code>scripts</code>, <code>test</code>).</p>
</blockquote>
<p>A <code>hello_world</code> folder would be created. Similar to Rust, the folder houses <em>src/main.nr</em> and <em>Nargo.toml</em> that contains the source code and environmental options of your Noir program respectively.</p>
<h3 id="intro-to-noir-syntax"><a class="header" href="#intro-to-noir-syntax">Intro to Noir Syntax</a></h3>
<p>Let us take a closer look at <em>main.nr</em>. The default <em>main.nr</em> generated should look like this:</p>
<pre><pre class="playground"><code class="language-rust">fn main(x : Field, y : pub Field) {
    constrain x != y;
}
</code></pre></pre>
<p>The first line of the program specifies the program's inputs:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>x : Field, y : pub Field
<span class="boring">}
</span></code></pre></pre>
<p>Program inputs in Noir are private by default (e.g. <code>x</code>), but can be labeled public using the keyword <code>pub</code> (e.g. <code>y</code>). To learn more about private and public values, check the <a href="getting_started/../language_concepts/data_types.html">Data Types</a> section.</p>
<p>The next line of the program specifies its body:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>constrain x != y;
<span class="boring">}
</span></code></pre></pre>
<p>The Noir syntax <code>constrain</code> can be interpreted as something similar to <code>assert</code> in other languages.</p>
<p>For more Noir syntax, check the <a href="getting_started/../language_concepts.html">Language Concepts</a> chapter.</p>
<h2 id="build-inoutput-files"><a class="header" href="#build-inoutput-files">Build In/Output Files</a></h2>
<p>Change directory into <em>hello_world</em> and build in/output files for your Noir program by running:</p>
<pre><code class="language-sh">$ cd hello_world
$ nargo check
</code></pre>
<p>Two additional files would be generated in your project directory:</p>
<p><em>Prover.toml</em> houses input values, and <em>Verifier.toml</em> houses public values.</p>
<h2 id="prove-our-noir-program"><a class="header" href="#prove-our-noir-program">Prove Our Noir Program</a></h2>
<p>Now that the project is set up, we can create a proof of correct execution on our Noir program.</p>
<p>Fill in input values for execution in the <em>Prover.toml</em> file. For example:</p>
<pre><code class="language-toml">x = &quot;1&quot;
y = &quot;2&quot;
</code></pre>
<p>Prove the valid execution of your Noir program with your preferred proof name, for example <code>p</code>:</p>
<pre><code class="language-sh">$ nargo prove p
</code></pre>
<p>A new folder <em>proofs</em> would then be generated in your project directory, containing the proof file <code>p.proof</code>.</p>
<p>The <em>Verifier.toml</em> file would also be updated with the public values computed from program execution (in this case the value of <code>y</code>):</p>
<pre><code class="language-toml">y = &quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot;
</code></pre>
<blockquote>
<p><strong>Note:</strong> Values in <em>Verifier.toml</em> are computed as 32-byte hex values.</p>
</blockquote>
<h2 id="verify-our-noir-program"><a class="header" href="#verify-our-noir-program">Verify Our Noir Program</a></h2>
<p>Once a proof is generated, we can verify correct execution of our Noir program by verifying the proof file.</p>
<p>Verify your proof of name <code>p</code> by running:</p>
<pre><code class="language-sh">$ nargo verify p
</code></pre>
<p>The verification will complete in silence if it is successful. If it fails, it will log the corresponding error instead.</p>
<p>Congratulations, you have now created and verified a proof for your very first Noir program!</p>
<p>In the <a href="getting_started/breakdown.html">next section</a>, we will go into more detail on each step performed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="breakdown"><a class="header" href="#breakdown">Breakdown</a></h1>
<p>This section breaks down our hello world program in section <em>1.2</em>.
We elaborate on the project structure and what the <code>prove</code> and <code>verify</code> commands did in the previous section.</p>
<h2 id="anatomy-of-a-nargo-project"><a class="header" href="#anatomy-of-a-nargo-project">Anatomy of a Nargo Project</a></h2>
<p>Upon creating a new project with <code>nargo new</code> and building the in/output files with <code>nargo check</code> commands, you would get a minimal Nargo project of the following structure:</p>
<pre><code>- src
- Prover.toml
- Verifier.toml
- Nargo.toml
</code></pre>
<p>The source directory <em>src</em> holds the source code for your Noir program. By default only a <em>main.nr</em> file will be generated within it.</p>
<p><em>Prover.toml</em> is used for specifying the input values for executing and proving the program. Optionally you may specify expected output values for prove-time checking as well.</p>
<p><em>Verifier.toml</em> contains public in/output values computed when executing the Noir program.</p>
<p><em>Nargo.toml</em> contains the environmental options of your project.</p>
<p><em>proofs</em> and <em>contract</em> directories will not be immediately visible until you create a proof or verifier contract respectively.</p>
<h3 id="mainnr"><a class="header" href="#mainnr">main.nr</a></h3>
<p>The <em>main.nr</em> file contains a <code>main</code> method, this method is the entry point into your Noir program.</p>
<p>In our sample program, <em>main.nr</em> looks like this:</p>
<pre><pre class="playground"><code class="language-rust">fn main(x : Field, y : Field) {
    constrain x != y;
}
</code></pre></pre>
<p>The parameters <code>x</code> and <code>y</code> can be seen as the API for the program and must be supplied by the prover. Since neither <code>x</code> nor <code>y</code> is marked as public, the verifier does not supply any inputs, when verifying the proof.</p>
<p>The prover supplies the values for <code>x</code> and <code>y</code> in the <em>Prover.toml</em> file.</p>
<p>As for the program body, <code>constrain</code> ensures the satisfaction of the condition (e.g. <code>x != y</code>) is constrained by the proof of the execution of said program (i.e. if the condition was not met, the verifier would reject the proof as an invalid proof).</p>
<h3 id="provertoml"><a class="header" href="#provertoml">Prover.toml</a></h3>
<p>The <em>Prover.toml</em> file is a file which the prover uses to supply his witness values(both private and public).</p>
<p>In our hello world program the <em>Prover.toml</em> file looks like this:</p>
<pre><code class="language-toml">x = &quot;1&quot;
y = &quot;2&quot;
</code></pre>
<p>When the command <code>nargo prove my_proof</code> is executed, two processes happen:</p>
<ol>
<li>
<p>Noir creates a proof that <code>x</code> which holds the value of <code>1</code> and <code>y</code> which holds the value of <code>2</code> is not equal. This not equal constraint is due to the line <code>constrain x != y</code>.</p>
</li>
<li>
<p>Noir creates and stores the proof of this statement in the <em>proofs</em> directory and names the proof file <em>my_proof</em>. Opening this file will display the proof in hex format.</p>
</li>
</ol>
<h2 id="verifying-a-proof"><a class="header" href="#verifying-a-proof">Verifying a Proof</a></h2>
<p>When the command <code>nargo verify my_proof</code> is executed, two processes happen:</p>
<ol>
<li>
<p>Noir checks in the <em>proofs</em> directory for a file called <em>my_proof</em></p>
</li>
<li>
<p>If that file is found, the proof's validity is checked</p>
</li>
</ol>
<blockquote>
<p><strong>Note:</strong> The validity of the proof is linked to the current Noir program; if the program is changed and the verifier verifies the proof, it will fail because the proof is not valid for the <em>modified</em> Noir program.</p>
</blockquote>
<p>In production, the prover and the verifier are usually two separate entities. A prover would retrieve the necessary inputs, execute the Noir program, generate a proof and pass it to the verifier. The verifier would then retrieve the public inputs from usually external sources and verifies the validity of the proof against it.</p>
<p>Take a private asset transfer as an example:</p>
<p>A user on browser as the prover would retrieve private inputs (e.g. the user's private key) and public inputs (e.g. the user's encrypted balance on-chain), compute the transfer, generate a proof and submit it to the verifier smart contract.</p>
<p>The verifier contract would then draw the user's encrypted balance directly from the blockchain and verify the proof submitted against it. If the verification passes, additional functions in the verifier contract could trigger (e.g. approve the asset transfer).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="solidity-verifier"><a class="header" href="#solidity-verifier">Solidity Verifier</a></h2>
<p>For certain applications, it may be desirable to run the verifier as a smart contract instead of on a local machine.</p>
<p>Compile a Solidity verifier contract for your Noir program by running:</p>
<pre><code class="language-sh">nargo codegen-verifier
</code></pre>
<p>A new <code>contract</code> folder would then be generated in your project directory, containing the Solidity file <code>plonk_vk.sol</code>. It can be deployed on any EVM blockchain acting as a verifier smart contract.</p>
<blockquote>
<p><strong>Note:</strong> It is possible to compile verifier contracts of Noir programs for other smart contract platforms as long as the proving backend supplies an implementation.</p>
<p>Barretenberg, the default proving backend Nargo is integrated with, supports compilation of verifier contracts in Solidity only for the time being.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript"><a class="header" href="#typescript">TypeScript</a></h1>
<p>Interactions with Noir programs can also be performed in TypeScript, which can come in handy when writing tests or when working in TypeScript-based projects like <a href="https://hardhat.org/">Hardhat</a>.</p>
<p>The following sections use the <a href="https://github.com/vezenovm/basic_mul_noir_example"><em>Standard Noir Example</em></a> as an example to dissect a typical Noir workflow in TypeScript, with specific focus on its:</p>
<ul>
<li>Test script <a href="https://github.com/vezenovm/basic_mul_noir_example/blob/master/test/1_mul.ts"><code>1_mul.ts</code></a></li>
<li>Noir program <a href="https://github.com/vezenovm/basic_mul_noir_example/blob/master/circuits/src/main.nr"><code>main.nr</code></a></li>
<li>Verifier contract generator script <a href="https://github.com/vezenovm/basic_mul_noir_example/blob/master/scripts/generate_sol_verifier.ts"><code>generate_sol_verifier.ts</code></a></li>
</ul>
<p>You are also welcome to revisit the full scripts <a href="https://github.com/vezenovm/basic_mul_noir_example/blob/master/test/1_mul.ts"><code>1_mul.ts</code></a> of <em>Standard Noir Example</em> and <a href="https://github.com/vezenovm/mastermind-noir/blob/master/test/mm.ts"><code>mm.ts</code></a> of <em>Mastermind in Noir</em> anytime for inspirations.</p>
<h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<p>Install <a href="https://classic.yarnpkg.com/lang/en/docs/install/">Yarn</a> and <a href="https://nodejs.org/en/download/">Node.js</a>.</p>
<p>Install Noir dependencies in your project by running:</p>
<pre><code class="language-bash">$ yarn add @noir-lang/noir_wasm @noir-lang/barretenberg @noir-lang/aztec_backend
</code></pre>
<p>And import the applicable functions into your TypeScript file by adding:</p>
<pre><code class="language-ts">// 1_mul.ts
import { compile, acir_read_bytes } from '@noir-lang/noir_wasm';
import { setup_generic_prover_and_verifier, create_proof, verify_proof, create_proof_with_witness } from '@noir-lang/barretenberg/dest/client_proofs';
import { packed_witness_to_witness, serialise_public_inputs, compute_witnesses } from '@noir-lang/aztec_backend';
</code></pre>
<h2 id="compiling"><a class="header" href="#compiling">Compiling</a></h2>
<p>To begin proving and verifying a Noir program, it first needs to be compiled by calling <code>noir_wasm</code>'s <code>compile</code> function:</p>
<pre><code class="language-ts">// 1_mul.ts
const compiled_program = compile(path.resolve(__dirname, &quot;../circuits/src/main.nr&quot;));
</code></pre>
<p>The <code>compiled_program</code> returned by the function contains the <a href="getting_started/../acir.html">ACIR</a> and the Application Binary Interface (ABI) of your Noir program. They shall be stored for proving your program later:</p>
<pre><code class="language-ts">// 1_mul.ts
let acir = compiled_program.circuit;
const abi = compiled_program.abi;
</code></pre>
<blockquote>
<p><strong>Note:</strong> Compiling with <code>noir_wasm</code> may lack some of the newer features that <code>nargo compile</code> offers. See the <a href="getting_started/typescript.html#proving-and-verifying-externally-compiled-files">Proving and Verifying Externally Compiled Files</a> section to learn more.</p>
</blockquote>
<h2 id="specifying-inputs"><a class="header" href="#specifying-inputs">Specifying Inputs</a></h2>
<p>Having obtained the compiled program, the program inputs shall then be specified in its ABI.</p>
<p><em>Standard Noir Example</em> is a program that multiplies input <code>x</code> with input <code>y</code> and returns the result:</p>
<pre><code class="language-noir"># main.nr
fn main(x: u32, y: pub u32) -&gt; pub u32 {
    let z = x * y;
    z
}
</code></pre>
<p>Hence, one valid scenario for proving could be <code>x = 3</code>, <code>y = 4</code> and <code>return = 12</code>:</p>
<pre><code class="language-ts">// 1_mul.ts
abi.x = 3;
abi.y = 4;
abi.return = 12;
</code></pre>
<blockquote>
<p><strong>Info:</strong> Return values are also required to be specified, as they are merely syntax sugar of inputs with equality constraints.</p>
</blockquote>
<blockquote>
<p><strong>Tip:</strong> To best protect the private inputs in your program (if applicable) from public knowledge, you should consider minimizing any passing around of inputs and deleting the inputs on the prover instance once the proof is created when designing your program.</p>
</blockquote>
<h2 id="initializing-prover--verifier"><a class="header" href="#initializing-prover--verifier">Initializing Prover &amp; Verifier</a></h2>
<p>Prior to proving and verifying, the prover and verifier have to first be initialized by calling <code>barretenberg</code>'s <code>setup_generic_prover_and_verifier</code> with your Noir program's ACIR:</p>
<pre><code class="language-ts">// 1_mul.ts
let [prover, verifier] = await setup_generic_prover_and_verifier(acir);
</code></pre>
<h2 id="proving"><a class="header" href="#proving">Proving</a></h2>
<p>The Noir program can then be executed and proved by calling <code>barretenberg</code>'s <code>create_proof</code> function:</p>
<pre><code class="language-ts">// 1_mul.ts
const proof = await create_proof(prover, acir, abi);
</code></pre>
<h2 id="verifying"><a class="header" href="#verifying">Verifying</a></h2>
<p>The <code>proof</code> obtained can be verified by calling <code>barretenberg</code>'s <code>verify_proof</code> function:</p>
<pre><code class="language-ts">// 1_mul.ts
const verified = await verify_proof(verifier, proof);
</code></pre>
<p>The function should return <code>true</code> if the entire process is working as intended, which can be asserted if you are writing a test script:</p>
<pre><code class="language-ts">// 1_mul.ts
expect(verified).eq(true);
</code></pre>
<h2 id="verifying-with-smart-contract"><a class="header" href="#verifying-with-smart-contract">Verifying with Smart Contract</a></h2>
<p>Alternatively, a verifier smart contract can be generated and used for verifying Noir proofs in TypeScript as well.</p>
<p>This could be useful if the Noir program is designed to be decentrally verified and/or make use of decentralized states and logics that is handled at the smart contract level.</p>
<p>To generate the verifier smart contract:</p>
<pre><code class="language-ts">// generate_sol_verifier.ts

// Imports
import { writeFileSync } from 'fs';

...

// Generate verifier contract
const sc = verifier.SmartContract();
syncWriteFile(&quot;../contracts/plonk_vk.sol&quot;, sc);

...

function syncWriteFile(filename: string, data: any) {
    writeFileSync(join(__dirname, filename), data, {
      flag: 'w',
    });
}
</code></pre>
<p>To verify a Noir proof using the verifier contract:</p>
<pre><code class="language-ts">// 1_mul.ts

// Imports
import { ethers } from &quot;hardhat&quot;;
import { Contract, ContractFactory, utils } from 'ethers';

...

// Deploy verifier contract
let Verifier: ContractFactory;
let verifierContract: Contract;

before(async () =&gt; {
    Verifier = await ethers.getContractFactory(&quot;TurboVerifier&quot;);
    verifierContract = await Verifier.deploy();
});

...

// Verify proof
const sc_verified = await verifierContract.verify(proof);
expect(sc_verified).eq(true)
</code></pre>
<h2 id="proving-and-verifying-externally-compiled-files"><a class="header" href="#proving-and-verifying-externally-compiled-files">Proving and Verifying Externally Compiled Files</a></h2>
<p>In some cases, <code>noir_wasm</code> may lack some of the newer features for compiling Noir programs due to separated upgrade workflows.</p>
<p>To benefit from the best of both worlds, a Noir program can be compiled with <code>nargo compile</code>, with the <code>.acir</code> and <code>.tr</code> files then passed into your TypeScript project for proving and verifying:</p>
<pre><code class="language-ts">// 1_mul.ts

// Parse acir
let acirByteArray = path_to_uint8array(path.resolve(__dirname, '../circuits/build/p.acir'));
let acir = acir_read_bytes(acirByteArray);

// Parse witness
let witnessByteArray = path_to_uint8array(path.resolve(__dirname, '../circuits/build/p.tr'));
const barretenberg_witness_arr = await packed_witness_to_witness(acir, witnessByteArray);

...

// Create proof
const proof = await create_proof_with_witness(prover, barretenberg_witness_arr);
</code></pre>
<blockquote>
<p><strong>Info:</strong> The <code>.acir</code> file is the ACIR of your Noir program, and the <code>.tr</code> file is the witness file. The witness file can be considered as program inputs parsed for your program's ACIR.</p>
</blockquote>
<p>See the <a href="getting_started/nargo/commands.html#nargo-compile-circuit_name">Commands</a> section to learn more about the <code>nargo compile</code> command.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="merkle-proof"><a class="header" href="#merkle-proof">Merkle Proof</a></h1>
<p>Let's walk through an example of a merkle membership proof in Noir that proves that a given leaf is in a merkle tree.</p>
<pre><code class="language-rust noplaypen">use dep::std;

fn main(message : [Field; 62], index : Field, hashpath : [Field; 40], root : Field) {
    let leaf = std::hash::hash_to_field(message);
    let is_member = std::merkle::check_membership(root, leaf, index, hashpath);
    constrain is_member == 1;
}

</code></pre>
<p>The above code uses the noir standard library to call both of the aforementioned components.</p>
<pre><code class="language-rust noplaypen">   let leaf = std::hash::hash_to_field(message);
</code></pre>
<p>The message is hashed using <code>hash_to_field</code>. The specific hash function that is being used is chosen by the backend. The only requirement is that this hash function can heuristically be used as a random oracle. If only collision resistance is needed, then one can call <code>std::hash::pedersen</code> instead.</p>
<pre><code class="language-rust noplaypen">    let is_member = std::merkle::check_membership(root, leaf, index, hashpath);
</code></pre>
<p>The leaf is then passed to a check_membership proof with the root, index and hashpath. <code>is_member</code> returns 1 if the leaf is a member of the merkle tree with the specified root, at the given index.</p>
<blockquote>
<p><strong>Note:</strong> It is possible to re-implement the merkle tree implementation without standard library. However, for most usecases, it is enough. In general, the standard library will always opt to be as conservative as possible, while striking a balance between efficiency.</p>
</blockquote>
<p>An example, the merkle membership proof, only requires a hash function that has collision resistance, hence a hash function like Pedersen is allowed, which in most cases is more efficient than the even more conservative sha256.</p>
<pre><code class="language-rust noplaypen">    constrain is_member == 1;
</code></pre>
<p>This last line, constrains the variable to be equal to 1. If 1 was changed to 0, this would create a proof that the leaf was not present at that specific index for that specific root. <em>Importantly, it would not prove that this leaf was not in the merkle tree.</em></p>
<p>Example Project: <a href="https://github.com/vezenovm/simple_shield">https://github.com/vezenovm/simple_shield</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>You can test your Noir programs using Noir circuits.</p>
<h2 id="testing-in-noir"><a class="header" href="#testing-in-noir">Testing in Noir</a></h2>
<p>Nargo will automatically compile and run any functions which have the decorator <code>#[test]</code> on them if you run <code>nargo test</code>.</p>
<p>For example if you have a program like:</p>
<pre><code class="language-rust noplaypen">fn add(x: u64, y: u64) -&gt; u64 {
    x + y
}

#[test]
fn test_add() {
    constrain add(2,2) == 4;
    constrain add(0,1) == 1;
    constrain add(1,0) == 1;
}
</code></pre>
<p>Running <code>nargo test</code> will test that the <code>test_add</code> function can be executed while satisfying the all the contraints which allows you to test that add returns the expected values. Test functions can't have any arguments currently.</p>
<p>This is much faster compared to testing in Typescript but the only downside is that you can't explicitly test that a certain set of inputs are invalid.
i.e. you can't say that you want add(2^64-1, 2^64-1) to fail.</p>
<p><code>nargo test</code> accepts an optional pattern argument to only run tests with names containing the given pattern.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-concepts"><a class="header" href="#language-concepts">Language Concepts</a></h1>
<p>In this chapter, we will go over the concepts that are being used in Noir. Specifically, we will learn about types, control flow, comments, functions and declarations.
For some concepts, we also explain the rationale as to why they were designed in this particular way. Recurring themes you will encounter in this section are <em>simplicity</em> and <em>safety</em>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutability"><a class="header" href="#mutability">Mutability</a></h1>
<p>Variables in noir can be declared mutable via the <code>mut</code> keyword.
Mutable variables can be reassigned to via
an assignment expression.</p>
<pre><code class="language-rust noplaypen">let x = 2;
x = 3; // error: x must be mutable to be assigned to

let mut y = 3;
let y = 4; // OK
</code></pre>
<p>The <code>mut</code> modifier can also apply to patterns:</p>
<pre><code class="language-rust noplaypen">let (a, mut b) = (1, 2);
a = 11; // error: a must be mutable to be assigned to
b = 12; // OK

let mut (c, d) = (3, 4);
c = 13; // OK
d = 14; // OK

// etc.
let MyStruct { x: mut y } = MyStruct { x: a }
// y is now in scope
</code></pre>
<p>Note that mutability in noir is local and everything is passed by value, so if a
called function mutates its parameters then the parent function will keep the old value of the parameters.</p>
<pre><code class="language-rust noplaypen">fn main() -&gt; Field {
    let x = 3;
    helper(x);
    x // x is still 3
}

fn helper(mut x: i32) {
    x = 4;
}
</code></pre>
<h3 id="constants"><a class="header" href="#constants">Constants</a></h3>
<p>A constant type is a value that does not change per circuit instance. This is different to a witness which changes per proof. If a constant type that is being used in your program is changed, then your circuit will also change.</p>
<p>Below we show how to declare a constant value:</p>
<pre><code class="language-rust noplaypen">fn main() {
    let a: comptime Field = 5;

    // `comptime Field` can also be inferred:
    let a = 5;
}
</code></pre>
<p>Note that variables declared as mutable may not be constants:</p>
<pre><code class="language-rust noplaypen">fn main() {
    // error: Cannot mark a comptime type as mutable - any mutation would remove its const-ness
    let mut a: comptime Field = 5;

    // a inferred as a private Field here
    let mut a = 5;
}
</code></pre>
<h3 id="globals"><a class="header" href="#globals">Globals</a></h3>
<p>Noir also supports global variables. However, they must be compile-time variables. If <code>comptime</code> is not explicitly written in the type annotation the compiler will implicitly specify the declaration as compile-time. They can then be used like any other compile-time variable inside functions. The global type can also be inferred by the compiler entirely. Globals can also be used to specify array annotations for function parameters and can be imported from submodules.</p>
<p>Globals are currently limited to Field, integer, and bool literals.</p>
<pre><code class="language-rust noplaypen">global N: Field = 5; // Same as `global N: comptime Field = 5`

fn main(x : Field, y : [Field; N]) {
    let res = x * N;

    constrain res == y[0];

    let res2 = x * mysubmodule::N;
    constrain res != res2;
}

mod mysubmodule {
    use dep::std;

    global N: Field = 10;

    fn my_helper() -&gt; comptime Field {
        let x = N;
        x
    }
}
</code></pre>
<h3 id="why-only-local-mutability"><a class="header" href="#why-only-local-mutability">Why only local mutability?</a></h3>
<p>Witnesses in a proving system are immutable in nature.
Noir aims to <em>closely</em> mirror this setting without applying additional overhead to the user.
Modeling a mutable reference is not as straightforward as on conventional architectures and
would incur some possibly unexpected overhead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-types"><a class="header" href="#data-types">Data Types</a></h1>
<p>Every value in Noir has a type, which determines which operations are valid for it.</p>
<p>All values in Noir are fundamentally composed of <code>Field</code> elements. For a more approachable developing experience, abstractions are added on top to introduce different data types in Noir.</p>
<p>Noir has two category of data types: primitive types (e.g. <code>Field</code>, integers, <code>bool</code>) and compound types that group primitive types (e.g. arrays, tuples, structs). Each value can either be private or public.</p>
<h2 id="private--public-types"><a class="header" href="#private--public-types">Private &amp; Public Types</a></h2>
<p>A <strong>private value</strong> is known only to the Prover, while a <strong>public value</strong> is known by both the Prover and Verifier. All primitive types (including individual fields of compound types) in Noir are private by default, and can be marked public when certain values are intended to be revealed to the Verifier.</p>
<blockquote>
<p><strong>Note:</strong> For public values defined in Noir programs paired with smart contract verifiers, once the proofs are verified on-chain the values can be considered known to everyone that has access to that blockchain.</p>
</blockquote>
<p>Public data types are treated no differently to private types apart from the fact that their values will be revealed in proofs generated. Simply changing the value of a public type will not change the circuit (where the same goes for changing values of private types as well).</p>
<p><em>Private values</em> are also referred to as <em>witnesses</em> sometimes.</p>
<blockquote>
<p><strong>Note:</strong> The terms private and public when applied to a type (e.g. <code>pub Field</code>) have a different meaning than when applied to a function (e.g. <code>pub fn foo() {}</code>).</p>
<p>The former is a visibility modifier for the Prover to interpret if a value should be made known to the Verifier, while the latter is a visibility modifier for the compiler to interpret if a function should be made accessible to external Noir programs like in other languages.</p>
</blockquote>
<h3 id="pub-modifier"><a class="header" href="#pub-modifier">pub Modifier</a></h3>
<p>All data types in Noir are private by default. Types are explicitly declared as public using the <code>pub</code> modifier:</p>
<pre><code class="language-rust noplaypen">fn main(x : Field, y : pub Field) -&gt; pub Field {
    x + y
}
</code></pre>
<p>In this example, <code>x</code> is <strong>private</strong> while <code>y</code> and <code>x + y</code> (the return value) are <strong>public</strong>. Note that visibility is handled <strong>per variable</strong>, so it is perfectly valid to have one input that is private and another that is public.</p>
<blockquote>
<p><strong>Note:</strong> Public types can only be declared through parameters on <code>main</code>.</p>
</blockquote>
<h2 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h2>
<p>A primitive type represents a single value. They can be private or public.</p>
<h3 id="the-field-type"><a class="header" href="#the-field-type">The Field Type</a></h3>
<p>The field type corresponds to the native field type of the proving backend.</p>
<p>The size of a Noir field depends on the elliptic curve's finite field for the proving backend adopted. For example, a field would be a 254-bit integer when paired with the default TurboPlonk backend that spans the Grumpkin curve.</p>
<p>Fields support integer arithmetic and are often used as the default numeric type in Noir:</p>
<pre><code class="language-rust noplaypen">fn main(x : Field, y : Field)  {
    let z = x + y;
}
</code></pre>
<p><code>x</code>, <code>y</code> and <code>z</code> are all private fields in this example. Using the <code>let</code> keyword we defined a new private value <code>z</code> constrained to be equal to <code>x + y</code>.</p>
<p>If proving efficiency is of priority, fields should be used as a default for solving problems. Smaller integer types (e.g. <code>u64</code>) incur extra range constraints.</p>
<h3 id="integer-types"><a class="header" href="#integer-types">Integer Types</a></h3>
<p>An integer type is a range constrained field type. The Noir frontend currently supports unsigned, arbitrary-sized integer types.</p>
<p>An integer type is specified first with the letter <code>u</code>, indicating its unsigned nature, followed by its length in bits (e.g. <code>32</code>). For example, a <code>u32</code> variable can store a value in the range of \([0,2^{32}-1]\):</p>
<pre><code class="language-rust noplaypen">fn main(x : Field, y : u32) {
    let z = x as u32 + y;
}
</code></pre>
<p><code>x</code>, <code>y</code> and <code>z</code> are all private values in this example. However, <code>x</code> is a field while <code>y</code> and <code>z</code> are unsigned 32-bit integers. If <code>y</code> or <code>z</code> exceeds the range \([0,2^{32}-1]\), proofs created will be rejected by the verifier.</p>
<blockquote>
<p><strong>Note:</strong> The default TurboPlonk backend supports both even (e.g. <code>u16</code>, <code>u48</code>) and odd (e.g. <code>u5</code>, <code>u3</code>) sized integer types.</p>
</blockquote>
<h3 id="the-boolean-type"><a class="header" href="#the-boolean-type">The Boolean Type</a></h3>
<p>The <code>bool</code> type in Noir has two possible values: <code>true</code> and <code>false</code>:</p>
<pre><code class="language-rust noplaypen">fn main() {
    let t = true;
    let f: bool = false;
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> When returning a boolean value, it will show up as a value of 1 for <code>true</code> and 0 for <code>false</code> in <em>Verifier.toml</em>.</p>
</blockquote>
<p>The boolean type is most commonly used in conditionals like <code>if</code> expressions and <code>constrain</code> statements. More about conditionals is covered in the <a href="language_concepts/./control_flow.html">Control Flow</a> and <a href="language_concepts/./constrain.html">Constrain Statement</a> sections.</p>
<h2 id="the-string-type"><a class="header" href="#the-string-type">The String Type</a></h2>
<p>Strings in Noir are fairly basic with their main use being for debugging via std::println.. Since circuit inputs need to be known at compile time, the string length for an input must be hardcoded into the circuit, like so:</p>
<pre><pre class="playground"><code class="language-rust">// **input**
// field = &quot;hello&quot;

fn main(string: str&lt;5&gt;) {
    let hello = &quot;hello&quot;;
    constrain string == hello;
}

</code></pre></pre>
<p>String manipulation isn't available at this time, but as long as you make the variable <code>mut</code>, you can replace it.</p>
<h2 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h2>
<p>A compound type groups together multiple values into one type. Elements within a compound type can be private or public.</p>
<h3 id="the-array-type"><a class="header" href="#the-array-type">The Array Type</a></h3>
<p>An array is one way of grouping together values into one compound type. Array types can be inferred or explicitly specified via the syntax <code>[&lt;Type&gt;; &lt;Size&gt;]</code>:</p>
<pre><code class="language-rust noplaypen">fn main(x : Field, y : Field) {
    let my_arr = [x, y];
    let your_arr: [Field; 2] = [x, y];
}
</code></pre>
<p>Here, both <code>my_arr</code> and <code>your_arr</code> are instantiated as an array containing two <code>Field</code> elements.</p>
<p>Array elements can be accessed using indexing:</p>
<pre><code class="language-rust noplaypen">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
</code></pre>
<p>All elements in an array must be of the same type (i.e. homogeneous). That is, an array cannot group a <code>Field</code> value and a <code>u8</code> value together for example.</p>
<h3 id="the-tuple-type"><a class="header" href="#the-tuple-type">The Tuple Type</a></h3>
<p>A tuple collects multiple values like an array, but with the added ability to collect values of different types:</p>
<pre><code class="language-rust noplaypen">fn main() {
    let tup: (u8, u64, Field) = (255, 500, 1000);
}
</code></pre>
<p>One way to access tuple elements is via destructuring using pattern matching:</p>
<pre><code class="language-rust noplaypen">fn main() {
    let tup = (1, 2);

    let (one, two) = tup;

    let three = one + two;
}
</code></pre>
<p>Another way to access tuple elements is via direct member access, using a period (<code>.</code>) followed by the index of the element we want to access. Index <code>0</code> corresponds to the first tuple element, <code>1</code> to the second and so on:</p>
<pre><code class="language-rust noplaypen">fn main() {
    let tup = (5, 6, 7, 8);

    let five = tup.0;
    let eight = tup.3;
}
</code></pre>
<h3 id="structs"><a class="header" href="#structs">Structs</a></h3>
<p>A struct also allows for grouping multiple values of different types. Unlike tuples, we can also name each field.</p>
<blockquote>
<p><strong>Note:</strong> The usage of <em>field</em> here refers to each element of the struct and is unrelated to the field type of Noir.</p>
</blockquote>
<p>Defining a struct requires giving it a name and listing each field within as <code>&lt;Key&gt;: &lt;Type&gt;</code> pairs:</p>
<pre><code class="language-rust noplaypen">struct Animal {
    hands: Field,
    legs: Field,
    eyes: u8,
}
</code></pre>
<p>An instance of a struct can then be created with actual values in <code>&lt;Key&gt;: &lt;Value&gt;</code> pairs in any order. Struct fields are accessible using their given names:</p>
<pre><code class="language-rust noplaypen">fn main() {
    let legs = 4;

    let dog = Animal {
        eyes: 2,
        hands: 0,
        legs,
    };

    let zero = dog.hands;
}
</code></pre>
<p>Structs can also be destructured in a pattern, binding each field to a new variable:</p>
<pre><code class="language-rust noplaypen">fn main() {
    let Animal { hands, legs: feet, eyes } = get_octopus();

    let ten = hands + feet + eyes as u8;
}

fn get_octopus() -&gt; Animal {
    let octopus = Animal {
        hands: 0,
        legs: 8,
        eyes: 2,
    };

    octopus
}
</code></pre>
<p>The new variables can be bound with names different from the original struct field names, as showcased in the <code>legs --&gt; feet</code> binding in the example above.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions in Noir follow the same semantics of Rust, though Noir does not support early returns.</p>
<p>To declare a function the <code>fn</code> keyword is used.</p>
<pre><code class="language-rust noplaypen">fn foo() {}
</code></pre>
<p>All parameters in a function must have a type and all types are known at compile time.
The parameter is pre-pended with a colon and the parameter type.
Multiple parameters are separated using a comma.</p>
<pre><code class="language-rust noplaypen">fn foo(x : Field, y : pub Field){}
</code></pre>
<p>The return type of a function can be stated by using the <code>-&gt;</code> arrow notation. The function below states that the foo function must return a <code>Field</code>. If the function returns no value, then the arrow is omitted.</p>
<pre><code class="language-rust noplaypen">fn foo(x : Field, y : pub Field) -&gt; Field {
    x + y
}
</code></pre>
<p>Note that a <code>return</code> keyword is unneeded in this case - the last expression in a function's body is returned.</p>
<h2 id="call-expressions"><a class="header" href="#call-expressions">Call Expressions</a></h2>
<p>Calling a function in Noir is executed by using the function name and passing in the necessary arguments.</p>
<p>Below we show how to call the <code>foo</code> function from the <code>main</code> function using a call expression:</p>
<pre><code class="language-rust noplaypen">fn main(x : Field, y : Field) {
    let z = foo(x);
}

fn foo(x : Field) -&gt; Field {
    x + x
}
</code></pre>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p>You can define methods in Noir on any struct type in scope.</p>
<pre><code class="language-rust noplaypen">struct MyStruct {
    foo: Field,
    bar: Field,
}

impl MyStruct {
    fn new(foo: Field) -&gt; MyStruct {
        MyStruct {
            foo,
            bar: 2,
        }
    }

    fn sum(self) -&gt; Field {
        self.foo + self.bar
    }
}

fn main() {
    let s = MyStruct::new(40);
    constrain s.sum() == 42;
}
</code></pre>
<p>Methods are just syntactic sugar for functions, so if we wanted to we could also call <code>sum</code> as follows:</p>
<pre><code class="language-rust noplaypen">constrain MyStruct::sum(s) == 42
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments"><a class="header" href="#comments">Comments</a></h1>
<p>A comment is a line in your codebase which the compiler ignores, however it can be read by programmers.</p>
<p>Here is a single line comment:</p>
<pre><code class="language-rust noplaypen">// This is a comment and is ignored
</code></pre>
<p><code>//</code> is used to tell the compiler to ignore the rest of the line.</p>
<p>Noir doesn't have multi-line comments, but you can emulate them via using <code>//</code> on each line</p>
<pre><code class="language-rust noplaypen">// This is a multi line
// comment, that is ignored by 
// the compiler
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<h2 id="loops"><a class="header" href="#loops">Loops</a></h2>
<p>Noir has one kind of loop: the <code>for</code> loop. <code>for</code> loops allow you to repeat a block of code multiple times.</p>
<p>The following block of code between the braces is run 10 times.</p>
<pre><code class="language-rust noplaypen">for i in 0..10 {
    // do something
};
</code></pre>
<h2 id="if-expressions"><a class="header" href="#if-expressions">If Expressions</a></h2>
<p>Noir supports <code>if-else</code> statements. The syntax is most similar to Rust's where it is not required for the statement's conditonal to be surrounded by parentheses.</p>
<pre><code class="language-rust noplaypen">let a = 0;
let mut x: u32 = 0;

if a == 0 {
    if a != 0 {
        x = 6;
    } else {
        x = 2;
    }
} else {
    x = 5;
    constrain x == 5;
}
constrain x == 2;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operations"><a class="header" href="#operations">Operations</a></h1>
<h2 id="table-of-supported-operations"><a class="header" href="#table-of-supported-operations">Table of Supported Operations</a></h2>
<table><thead><tr><th align="left">Operation</th><th align="center">Description</th><th align="right">Requirements</th></tr></thead><tbody>
<tr><td align="left">+</td><td align="center">Adds two concealed types together</td><td align="right">Types must be concealed</td></tr>
<tr><td align="left">-</td><td align="center">Subtracts two concealed types together</td><td align="right">Types must be concealed</td></tr>
<tr><td align="left">*</td><td align="center">Multiplies two concealed types together</td><td align="right">Types must be concealed</td></tr>
<tr><td align="left">/</td><td align="center">Divides two concealed types together</td><td align="right">Types must be concealed</td></tr>
<tr><td align="left">^</td><td align="center">XOR two concealed types together</td><td align="right">Types must be integer</td></tr>
<tr><td align="left">&amp;</td><td align="center">AND two concealed types together</td><td align="right">Types must be integer</td></tr>
<tr><td align="left">&lt;&lt;</td><td align="center">Left shift an integer by another integer amount</td><td align="right">Types must be integer</td></tr>
<tr><td align="left">&gt;&gt;</td><td align="center">Right shift an integer by another integer amount</td><td align="right">Types must be integer</td></tr>
<tr><td align="left">!</td><td align="center">Bitwise not of a value</td><td align="right">Type must be integer or boolean</td></tr>
<tr><td align="left">&lt;</td><td align="center">returns a bool if one value is less than the other</td><td align="right">Upper bound must have a known bit size</td></tr>
<tr><td align="left">&lt;=</td><td align="center">returns a bool if one value is less than or equal to the other</td><td align="right">Upper bound must have a known bit size</td></tr>
<tr><td align="left">&gt;</td><td align="center">returns a bool if one value is more than the other</td><td align="right">Upper bound must have a known bit size</td></tr>
<tr><td align="left">&gt;=</td><td align="center">returns a bool if one value is more than or equal to the other</td><td align="right">Upper bound must have a known bit size</td></tr>
<tr><td align="left">==</td><td align="center">returns a bool if one value is equal to the other</td><td align="right">Both types must not be constants</td></tr>
<tr><td align="left">!=</td><td align="center">returns a bool if one value is not equal to the other</td><td align="right">Both types must not be constants</td></tr>
</tbody></table>
<h3 id="predicate-operators"><a class="header" href="#predicate-operators">Predicate Operators</a></h3>
<p><code>&lt;,&lt;=, !=, == , &gt;, &gt;=</code> are known as predicate/comparison operations because they compare two values. This differs from the operations such as <code>+</code> where the operands are used in <em>computation</em>.</p>
<h3 id="bitwise-operations-example"><a class="header" href="#bitwise-operations-example">Bitwise Operations Example</a></h3>
<pre><code class="language-rust noplaypen">fn main(x : Field) {
    let y = x as u32;
    let z = y &amp; y;
}
</code></pre>
<p><code>z</code> is implicitly constrained to be the result of <code>y &amp; y</code>. The <code>&amp;</code> operand is used to denote bitwise <code>&amp;</code>.</p>
<blockquote>
<p><code>x &amp; x</code> would not compile as <code>x</code> is a <code>Field</code> and not an integer type.</p>
</blockquote>
<h3 id="logical-operators"><a class="header" href="#logical-operators">Logical Operators</a></h3>
<p>Noir has no support for the logical operators <code>||</code> and <code>&amp;&amp;</code>.
This is because encoding the short-circuiting that these operators require can be inefficient for Noir's backend.
Instead you can use the bitwise operators <code>|</code> and <code>&amp;</code> which operate indentically for booleans, just without the short-circuiting.</p>
<pre><code class="language-rust noplaypen">let my_val = 5;

let mut flag = 1;
if (my_val &gt; 6) | (my_val == 0) {
    flag = 0;
}
constrain flag == 1;

if (my_val != 10) &amp; (my_val &lt; 50) {
    flag = 0;
}
constrain flag == 0;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constrain-statement"><a class="header" href="#constrain-statement">Constrain Statement</a></h1>
<p>Noir includes a special keyword <code>constrain</code> which will explicitly constrain the predicate/comparison expression that follows to be true.
If this expression is false at runtime, the program will fail to be proven.</p>
<h3 id="constrain-statement-example"><a class="header" href="#constrain-statement-example">Constrain statement example</a></h3>
<pre><code class="language-rust noplaypen">fn main(x : Field, y : Field) {
    constrain x == y;
}
</code></pre>
<p>The above snippet compiles because <code>==</code> is a predicate operation. Conversely, the following will not compile:</p>
<pre><code class="language-rust noplaypen">fn main(x : Field, y : Field) {
    constrain x + y;
}
</code></pre>
<blockquote>
<p>The rationale behind this not compiling is due to ambiguity. It is not clear if the above should equate to <code>x + y == 0</code> or if it should check the truthiness of the result.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="noir-standard-library"><a class="header" href="#noir-standard-library">Noir Standard Library</a></h1>
<p>Noir features a standard library with some ready-to-use, built-in structures. To use them, you should import the <code>std</code> library, like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>use dep::std;
<span class="boring">}
</span></code></pre></pre>
<p>You should then have these constructs available. For example, you can now call the <code>std::hash::pedersen</code> function like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data : [Field; 2] = [42, 42];
std::hash::pedersen(data);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="logging"><a class="header" href="#logging">Logging</a></h2>
<p>The standard library provides a familiar <code>println</code> statement you can use. Despite being a limited implementation of rust's <code>println!</code> macro, this construct can be useful for debugging.</p>
<pre><pre class="playground"><code class="language-rust">use dep::std;

fn main(string: pub str&lt;5&gt;) {
    let x = 5;
    std::println(x)
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="field"><a class="header" href="#field">Field</a></h1>
<p>After declaring a Field, you can use these common methods on it <sup class="footnote-reference"><a href="#migrationNote">1</a></sup>:</p>
<h2 id="to_le_bits"><a class="header" href="#to_le_bits">to_le_bits</a></h2>
<p>Transforms the field into an array of bits, Little Endian.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn to_le_bits&lt;N&gt;(_x : Field, _bit_size: u32) -&gt; [u1; N]
<span class="boring">}
</span></code></pre></pre>
<p>example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let field = 2
    let bits = field.to_le_bits(32);
}
</code></pre></pre>
<h2 id="to_le_bytes"><a class="header" href="#to_le_bytes">to_le_bytes</a></h2>
<p>Transforms into an array of bytes, Little Endian</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn to_le_bytes(_x : Field, byte_size: u32) -&gt; [u8]
<span class="boring">}
</span></code></pre></pre>
<p>example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let field = 2
    let bytes = field.to_le_bytes(4);
}
</code></pre></pre>
<h2 id="to_le_radix"><a class="header" href="#to_le_radix">to_le_radix</a></h2>
<p>Decomposes into a vector over the specificed base, Little Endian</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn to_le_radix(_x : Field, _radix: u32, _result_len: u32) -&gt; [u8]
<span class="boring">}
</span></code></pre></pre>
<p>example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let field = 2
    let radix = field.to_le_radix(256, 4);
}
</code></pre></pre>
<h2 id="to_be_radix"><a class="header" href="#to_be_radix">to_be_radix</a></h2>
<p>Decomposes into a vector over the specificed base, Big Endian</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn to_be_radix(_x : Field, _radix: u32, _result_len: u32) -&gt; [u8]
<span class="boring">}
</span></code></pre></pre>
<p>example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let field = 2
    let radix = field.to_be_radix(256, 4);
}
</code></pre></pre>
<h2 id="pow_32"><a class="header" href="#pow_32">pow_32</a></h2>
<p>Returns the value to the power of the specificied exponent</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn pow_32(self, exponent: Field) -&gt; Field
<span class="boring">}
</span></code></pre></pre>
<p>example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let field = 2
    let pow = field.pow_32(4);
    constrain pow == 16;
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array"><a class="header" href="#array">Array</a></h1>
<p>For convenience, the STD provides some ready-to-use, common methods for arrays<sup class="footnote-reference"><a href="#migrationNote">1</a></sup>:</p>
<h2 id="len"><a class="header" href="#len">len</a></h2>
<p>Returns the length of an array</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn len&lt;T, N&gt;(_array: [T; N]) -&gt; comptime Field
<span class="boring">}
</span></code></pre></pre>
<p>example</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let array = [42, 42]
    constrain arr.len() == 2;
}
</code></pre></pre>
<h2 id="sort"><a class="header" href="#sort">sort</a></h2>
<p>Returns a new sorted array. The original array remains untouched. Notice that this function will only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting logic it uses internally is optimized specifically for these values. If you need a sort function to sort any type, you should use the function <code>sort_via</code> described below.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sort&lt;T, N&gt;(_array: [T; N]) -&gt; [T; N]
<span class="boring">}
</span></code></pre></pre>
<p>example</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let arr = [42, 32]
    let sorted = arr.sort();
    constrain sorted == [32, 42];
}
</code></pre></pre>
<h2 id="sort_via"><a class="header" href="#sort_via">sort_via</a></h2>
<p>Sorts the array with a custom comparison function</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sort_via&lt;T, N&gt;(mut a: [T; N], ordering: fn(T, T) -&gt; bool) -&gt; [T; N]
<span class="boring">}
</span></code></pre></pre>
<p>example</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let arr = [42, 32]
    let sorted_ascending = arr.sort_via(|a, b| a &lt; b);
    constrain sorted_ascending == [32, 42]; // verifies

    let sorted_descending = arr.sort_via(|a, b| a &gt; b);
    constrain sorted_descending == [32, 42]; // does not verify
}
</code></pre></pre>
<h2 id="fold"><a class="header" href="#fold">fold</a></h2>
<p>Applies a function to each element of the array, returning the final accumulated value. The first parameter is the initial value.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fold&lt;U&gt;(mut accumulator: U, f: fn(U, T) -&gt; U) -&gt; U
<span class="boring">}
</span></code></pre></pre>
<p>This is a left fold, so the given function will be applied to the accumulator and first element of the array, then the second, and so on. For a given call the expected result would be equivalent to:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a1 = [1];
let a2 = [1, 2];
let a3 = [1, 2, 3];

let f = |a, b| a - b;
a1.fold(10, f)  //=&gt; f(10, 1)
a2.fold(10, f)  //=&gt; f(f(10, 1), 2)
a3.fold(10, f)  //=&gt; f(f(f(10, 1), 2), 3)
<span class="boring">}
</span></code></pre></pre>
<p>example:</p>
<pre><pre class="playground"><code class="language-rust">
fn main() {
    let arr = [2,2,2,2,2]
    let folded = arr.fold(0, |a, b| a + b);
    constrain folded == 10;
}

</code></pre></pre>
<h2 id="reduce"><a class="header" href="#reduce">reduce</a></h2>
<p>Same as fold, but uses the first element as starting element.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn reduce&lt;T, N&gt;(f: fn(T, T) -&gt; T) -&gt; T 
<span class="boring">}
</span></code></pre></pre>
<p>example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let arr = [2,2,2,2,2]
    let reduced = arr.reduce(|a, b| a + b);
    constrain reduced == 10;
}
</code></pre></pre>
<h2 id="all"><a class="header" href="#all">all</a></h2>
<p>Returns true if all the elements satisfy the given predicate</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn all&lt;T, N&gt;(predicate: fn(T) -&gt; bool) -&gt; bool
<span class="boring">}
</span></code></pre></pre>
<p>example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let arr = [2,2,2,2,2]
    let all = arr.all(|a| a == 2);
    constrain all;
}
</code></pre></pre>
<h2 id="any"><a class="header" href="#any">any</a></h2>
<p>Returns true if any of the elements satisfy the given predicate</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn any&lt;T, N&gt;(predicate: fn(T) -&gt; bool) -&gt; bool
<span class="boring">}
</span></code></pre></pre>
<p>example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let arr = [2,2,2,2,5]
    let any = arr.any(|a| a == 5);
    constrain any;
}

</code></pre></pre>
<div class="footnote-definition" id="migrationNote"><sup class="footnote-definition-label">1</sup>
<p>Migration Note: These methods were previously free functions, called via <code>std::array::len()</code>. For the sake of ease of use and readability, these functions are now methods and the old syntax for them is now deprecated.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="merkle-trees"><a class="header" href="#merkle-trees">Merkle Trees</a></h1>
<h2 id="check_membership"><a class="header" href="#check_membership">check_membership</a></h2>
<p>Returns 1 if the specified leaf is at the given index on a tree</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn check_membership(_root : Field, _leaf : Field, _index : Field, _hash_path: [Field]) -&gt; Field
<span class="boring">}
</span></code></pre></pre>
<p>example:</p>
<pre><pre class="playground"><code class="language-rust">/**
 * 
    index = &quot;0&quot;
    priv_key = &quot;0x000000000000000000000000000000000000000000000000000000616c696365&quot;
    secret = &quot;0x1929ea3ab8d9106a899386883d9428f8256cfedb3c4f6b66bf4aa4d28a79988f&quot;
    root = &quot;0x2f36d4404719a30512af45be47c9732e916cb131933102b04ba6432602db209c&quot;
    hash_path = [
    &quot;0x1e61bdae0f027b1b2159e1f9d3f8d00fa668a952dddd822fda80dc745d6f65cc&quot;,
    &quot;0x0e4223f3925f98934393c74975142bd73079ab0621f4ee133cee050a3c194f1a&quot;,
    &quot;0x2fd7bb412155bf8693a3bd2a3e7581a679c95c68a052f835dddca85fa1569a40&quot;
    ]
 */

fn main(root : Field, index : Field, hash_path : [Field; 3], secret: Field, priv_key: Field) {
    constrain index == index;

    let pubkey = std::scalar_mul::fixed_base(priv_key);
    let pubkey_x = pubkey[0];
    let pubkey_y = pubkey[1];
    let note_commitment = std::hash::pedersen([pubkey_x, pubkey_y, secret]);

    let root = std::merkle::check_membership(root, note_commitment[0], index, hash_path);
    std::println(root);
}
</code></pre></pre>
<h2 id="check_membership_in_noir"><a class="header" href="#check_membership_in_noir">check_membership_in_noir</a></h2>
<p>Behaves exactly the same as above, but it's computed in Noir in order to accept many backends.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn check_membership_in_noir(root : Field, leaf : Field, index : Field, hash_path: [Field]) -&gt; Field
<span class="boring">}
</span></code></pre></pre>
<p>For examples, you can literally replace <code>check_membership</code> for this method, in the above example.</p>
<h2 id="compute_root_from_leaf"><a class="header" href="#compute_root_from_leaf">compute_root_from_leaf</a></h2>
<p>Returns the root of the tree from the provided leaf and its hashpath, using a pedersen hash</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn compute_root_from_leaf(leaf : Field, index : Field, hash_path: [Field]) -&gt; Field
<span class="boring">}
</span></code></pre></pre>
<p>example:</p>
<pre><pre class="playground"><code class="language-rust">/**
    index = &quot;0&quot;
    priv_key = &quot;0x000000000000000000000000000000000000000000000000000000616c696365&quot;
    secret = &quot;0x1929ea3ab8d9106a899386883d9428f8256cfedb3c4f6b66bf4aa4d28a79988f&quot;
    note_hash_path = [
    &quot;0x1e61bdae0f027b1b2159e1f9d3f8d00fa668a952dddd822fda80dc745d6f65cc&quot;,
    &quot;0x0e4223f3925f98934393c74975142bd73079ab0621f4ee133cee050a3c194f1a&quot;,
    &quot;0x2fd7bb412155bf8693a3bd2a3e7581a679c95c68a052f835dddca85fa1569a40&quot;
    ]
 */
fn main(index : Field, priv_key : Field, secret : Field, note_hash_path : [Field; 3]) {
    constrain index == index;

    let pubkey = std::scalar_mul::fixed_base(priv_key);
    let pubkey_x = pubkey[0];
    let pubkey_y = pubkey[1];
    let note_commitment = std::hash::pedersen([pubkey_x, pubkey_y, secret]);

    let root = std::merkle::compute_root_from_leaf(note_commitment[0], index, note_hash_path);
    std::println(root);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cryptographic-primitives"><a class="header" href="#cryptographic-primitives">Cryptographic primitives</a></h1>
<p>Some cryptographic primitives are already developed and ready-to-use for any Noir project:</p>
<h2 id="sha256"><a class="header" href="#sha256">sha256</a></h2>
<p>Given an array of bytes, returns the sha256 of it:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = [163, 117, 178, 149] // some random bytes
    let hash = std::hash::sha256(x);
}
</code></pre></pre>
<h2 id="blake2s"><a class="header" href="#blake2s">blake2s</a></h2>
<p>Given an array of bytes, returns the Blake2 of it:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = [163, 117, 178, 149] // some random bytes
    let hash = std::hash::blake2s(x);
}
</code></pre></pre>
<h2 id="pedersen"><a class="header" href="#pedersen">pedersen</a></h2>
<p>Given an array of Fields, returns the Pedersen hash of it:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = [163, 117, 178, 149] // some random bytes
    let hash = std::hash::pedersen(x);
}
</code></pre></pre>
<h2 id="mimc_bn254-and-mimc"><a class="header" href="#mimc_bn254-and-mimc">mimc_bn254 and mimc</a></h2>
<p><code>mimc_bn254</code> is <code>mimc</code>, but with hardcoded parameters for the BN254 curve. You can use it by providing an array of Fields, and it returns a Field with the hash. You can use the <code>mimc</code> method if you're willing to input your own constants:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn mimc&lt;N&gt;(x: Field, k: Field, constants: [Field; N], exp : Field) -&gt; Field
<span class="boring">}
</span></code></pre></pre>
<p>otherwise, use the <code>mimc_bn254</code> method:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn mimc_bn254&lt;N&gt;(array: [Field; N]) -&gt; Field
<span class="boring">}
</span></code></pre></pre>
<p>example:</p>
<pre><pre class="playground"><code class="language-rust">
fn main() {
    let x = [163, 117, 178, 149] // some random bytes
    let hash = std::hash::mimc_bn254(x);
}
</code></pre></pre>
<h2 id="scalar_mulfixed_base"><a class="header" href="#scalar_mulfixed_base">scalar_mul::fixed_base</a></h2>
<p>Performs scalar multiplication over the embedded curve whose coordinates are defined by the configured noir field. For the BN254 scalar field, this is BabyJubJub or Grumpkin.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fixed_base(_input : Field) -&gt; [Field; 2]
<span class="boring">}
</span></code></pre></pre>
<p>example</p>
<pre><pre class="playground"><code class="language-rust">fn main(x : Field) {
    let scal = std::scalar_mul::fixed_base(x);
    std::println(scal);
}
</code></pre></pre>
<h2 id="schnorrverify_signature"><a class="header" href="#schnorrverify_signature">schnorr::verify_signature</a></h2>
<p>Verifier for Schnorr signatures</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn verify_signature(_public_key_x: Field, _public_key_y: Field, _signature: [u8; 64], _message: [u8]) -&gt; Field
<span class="boring">}
</span></code></pre></pre>
<h2 id="ecdsa_secp256k1verify_signature"><a class="header" href="#ecdsa_secp256k1verify_signature">ecdsa_secp256k1::verify_signature</a></h2>
<p>Verifier for ECDSA Secp256k1 signatures</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn verify_signature(_public_key_x : [u8; 32], _public_key_y : [u8; 32], _signature: [u8; 64], _message: [u8]) -&gt; Field
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules-packages-crates"><a class="header" href="#modules-packages-crates">Modules, Packages, Crates</a></h1>
<p>In this section, we describe the package, crate and module system. As mentioned in the introduction, this will largely follow the design choice chosen by Rust, as such, it may be helpful to be familiar with <a href="https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">Rust's system</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crates-and-packages"><a class="header" href="#crates-and-packages">Crates and Packages</a></h1>
<h2 id="crates"><a class="header" href="#crates">Crates</a></h2>
<p>A crate is the smallest amount of code that the Noir compiler considers at a time.
Crates can contain modules, and the modules may be defined in other files that get compiled with the crate, as we’ll see in the coming sections.</p>
<h3 id="crate-types"><a class="header" href="#crate-types">Crate Types</a></h3>
<p>A Noir crate can come in one of two forms: a binary crate or a library crate.</p>
<p><em>Binary crates</em> are programs which you can compile to an ACIR circuit which you can then create proofs against. Each must have a function called <code>main</code> that defines the ACIR circuit which is to be proved.</p>
<p><em>Library crates</em> don't have a <code>main</code> function and they don't compile down to ACIR. Instead they define functionality intended to be shared with multiple projects, and eventually included in a binary crate.</p>
<h3 id="crate-root"><a class="header" href="#crate-root">Crate Root</a></h3>
<p>Every crate has a root, which is the source file that the compiler starts, this is also known as the root module. The Noir compiler does not enforce any conditions on the name of the file which is the crate root, however if you are compiling via Nargo the crate root must be called <code>lib.nr</code> or <code>main.nr</code> for library or binary crates respectively.</p>
<h2 id="packages"><a class="header" href="#packages">Packages</a></h2>
<p>A Nargo <em>package</em> is a collection of one of more crates that provides a set of functionality. A package must include a Nargo.toml file.</p>
<p>A package <em>must</em> contain either a library or a binary crate, but not both.</p>
<h3 id="differences-from-cargo-packages"><a class="header" href="#differences-from-cargo-packages">Differences from Cargo Packages</a></h3>
<p>One notable difference between Rust's Cargo and Noir's Nargo is that while Cargo allows a package to contain an unlimited number of binary crates and a single library crate, Nargo currently only allows a package to contain a single crate.</p>
<p>In future this restriction may be lifted to allow a Nargo package to contain both a binary and library crate or multiple binary crates.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>Noir's module system follows the same convention as the <em>newer</em> version of Rust's module system.</p>
<h2 id="purpose-of-modules"><a class="header" href="#purpose-of-modules">Purpose of Modules</a></h2>
<p>Modules are used to organise files. Without modules all of your code would need to live in a single file. In Noir, the compiler does not automatically scan all of your files to detect modules. This must be done explicitly by the developer.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="importing-a-module-in-the-crate-root"><a class="header" href="#importing-a-module-in-the-crate-root">Importing a module in the crate root</a></h3>
<p>Filename : <code>src/main.nr</code></p>
<pre><code class="language-rust noplaypen">mod foo;

fn main() {
    foo::hello_world();
}
</code></pre>
<p>Filename : <code>src/foo.nr</code></p>
<pre><code class="language-rust noplaypen">fn from_foo() {}
</code></pre>
<p>In the above snippet, the crate root is the <code>src/main.nr</code> file.
The compiler sees the module declaration <code>mod foo</code> which prompts it to look for a foo.nr file.</p>
<p>Visually this module hierarchy looks like the following :</p>
<pre><code>crate
 ├── main
 │
 └── foo
      └── from_foo
      
</code></pre>
<h3 id="sub-modules"><a class="header" href="#sub-modules">Sub-modules</a></h3>
<p>Filename : <code>src/main.nr</code></p>
<pre><code class="language-rust noplaypen">mod foo;

fn main() {
    foo::from_foo();
}
</code></pre>
<p>Filename : <code>src/foo.nr</code></p>
<pre><code class="language-rust noplaypen">mod bar;
fn from_foo() {}
</code></pre>
<p>Filename : <code>src/foo/bar.nr</code></p>
<pre><code class="language-rust noplaypen">fn from_bar() {}
</code></pre>
<p>In the above snippet, we have added an extra module to the module tree; <code>bar</code>. <code>bar</code> is a submodule of <code>foo</code> hence we declare bar in <code>foo.nr</code> with <code>mod bar</code>. Since <code>foo</code> is not the crate root, the compiler looks for the file associated with the <code>bar</code> module in <code>src/foo/bar.nr</code></p>
<p>Visually the module hierarchy looks as follows:</p>
<pre><code>crate
 ├── main
 │
 └── foo
      ├── from_foo
      └── bar
           └── from_bar
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h1>
<p>Nargo allows you to upload packages to GitHub and use them as dependencies.</p>
<h2 id="specifying-a-dependency"><a class="header" href="#specifying-a-dependency">Specifying a dependency</a></h2>
<pre><code>hello_world = { tag = &quot;v0.5&quot;, git = &quot;https://github.com/kevaundray/hello-world-noir&quot;}
</code></pre>
<p>Specifying a dependency requires a tag to a specific commit and the git url to the url containing the package.</p>
<p>Currently, there are no requirements on the tag contents. If requirements are added, it would follow semver 2.0 guidelines.</p>
<blockquote>
<p>Note: Without a <code>tag</code> , there would be no versioning and dependencies would change each time you compile your project.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="acir-abstract-circuit-intermediate-representation"><a class="header" href="#acir-abstract-circuit-intermediate-representation">ACIR (Abstract Circuit Intermediate Representation)</a></h2>
<p>The purpose of ACIR is to act as an intermediate layer between the proof system that Noir chooses to compile to and the Noir syntax.
This separation between proof system and programming language, allows those who want to integrate proof systems to have a stable target, moreover it allows the frontend to compile to any ACIR compatible proof system.</p>
<p>ACIR additionally allows proof systems to supply a fixed list of optimised blackbox functions that the frontend can access. Examples of this would be SHA256, PEDERSEN and SCHNORRSIGVERIFY.</p>
<h2 id="compiling-a-proof"><a class="header" href="#compiling-a-proof">Compiling a Proof</a></h2>
<p>When inside of a given Noir project the command <code>nargo compile my_proof</code> will perform two processes.</p>
<ul>
<li>
<p>First, compile the Noir program to its ACIR and solve the circuit's witness. </p>
</li>
<li>
<p>Second, create a new <code>build/</code> directory to store the ACIR, <code>my_proof.acir</code>, and the solved witness, <code>my_proof.tr</code></p>
</li>
</ul>
<p>These can be used by the Noir Typescript wrapper to generate a prover and verifier inside of Typescript rather than in Nargo. This will be discussed further in another section.</p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="./acir_diagram.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features-coming-soon"><a class="header" href="#features-coming-soon">Features Coming Soon</a></h1>
<h3 id="isize"><a class="header" href="#isize">Isize</a></h3>
<p>Signed integers such as i32 and i64 allow one to express more circuits. They are partially supported but need to be finalised. </p>
<h3 id="recursion"><a class="header" href="#recursion">Recursion</a></h3>
<p>Recursion is becoming feasible in circuits, hence Noir will have native support for it. Currently, only composition is supported. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="license"><a class="header" href="#license">LICENSE</a></h1>
<p>Noir will be dual licensed under MIT/Apache (Version 2.0).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
                
    </body>
</html>
